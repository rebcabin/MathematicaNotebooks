(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: RotationQuaternions *) 
(* :Author: bbeckman *)
(* :Summary: Utility functions for rotation quaternions. *)
(* :Context: Dzhanybekhov`RotationQuaternions` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 May 21 2014 *)
(* :Mathematica version: 9.0 for Mac OS X x86 (64-bit) (January 24, 2013) *)
(* :Discussion: Rotation quaternions have the form Quaternion[Cos[\[Phi]/2],Sin[\[Phi]/2]*<normalized3Vector>]. They encode a rotation of \[Phi] about an axis aligned with the normalized3Vector. They can be used to rotate ordinary 3-vectors and 3-dimensional coordinate frames. They have many advantages over rotation matrices and Euler angles.v*)
(* :Dependencies: Quaternions` *)


BeginPackage["Dzhanybekhov`RotationQuaternions`"];


(* :Code Section (Call Unprotect and ClearAll): *)


Unprotect[rq,ranv,ran\[Theta],ranrq,rqw,vq,wrq,\[Theta]rq,vrq,\[Theta]vrq,qv,rv,rf];
ClearAll[rq,ranv,ran\[Theta],ranrq,rqw,vq,wrq,\[Theta]rq,vrq,\[Theta]vrq,qv,rv,rf];


(* :Usage Messages: *)


(* :Code Section: *)


rq::usage = "rq[\[Theta],vec3] produces a rotation quaternion for the given angle counterclockwise about the given 3-vector direction. rq[\[Theta],x,y,z] accepts the components of the direction vector individually.";


ranv::usage="ranv[] produces a random 3-vector with components independently sampled uniformly from -1 to 1, inclusive.";


ran\[Theta]::usage="ran\[Theta][] produces a random angle between 0 and 2\[Pi], inclusive.";


ranrq::usage="ranrq[] produces a random rotation quaternion, with a random angle uniformly between 0 and 2\[Pi] and a vector with rectangular components independently and uniformly between -1 and 1.";


rqw::usage="rqw[w] produces a rotation quaternion from a twist vector, which is a 3-vector whose magnitude is the angle of twist in radians counterclockwise about an axis aligned with the direction of the vector.";


vq::usage="vq[q] extracts the vector part of the general quaternion q.";


wrq::usage="wrq[rq] produces a twist vector from a rotation quaternion. A twist vector is a 3-vector whose magnitude is the angle of twist in radiancs counterclockwise about an axis aligned with the direction of the vector.";


\[Theta]rq::usage="\[Theta]rq[rq] extracts the angle of rotation from the rotation quaternion rq. \[Theta]rq[rq] is equivalent to 2\[NonBreakingSpace]ArcCos[rq\[LeftDoubleBracket]1\[RightDoubleBracket]].";


vrq::usage="vrq[rq] extracts the direction of rotation as a normalized 3-vector from the rotation quaternion rq.";


\[Theta]vrq::usage="\[Theta]vrq[rq] extracts the angle and direction of rotation from the rotation quaternion rq and wraps them in a list. \[Theta]vrq[rq] is equivalent to {\[Theta]rq[rq],vrq[rq]}";


qv::usage="qv[v] produces a quaternion representative of the 3-vector v.";


rv::usage="rv[rq,v] produces a new 3-vector by rotating the given 3-vector v as specifed by the rotation quaternion rq. The original vector is not changed.";


rf::usage="rf[rq,v] produces a new 3-vector from v with components in a reference frame computed by rotating the old reference frame as specified by the rotation quaternion rq; equivalent to rv[rq,-v].";


(* :Error Messages: *)


(* :Code Section: *)


rq::argerr="Expected either an angle and a 3-vector or an angle and 3 vector components; instead got `1`.";
ranv::argerr="No arguments expected; instead got `1`.";
ran\[Theta]::argerr="No arguments expected; instead got `1`.";
ranrq::argerr="No arguments expected; instead got `1`.";
rqw::argerr="Expected one 3-vector argument; instead got `1`.";
vq::argerr="Expected one quaternion argument; instead got `1`.";
wrq::argerr="Expected one quaternion argument; instead got `1`.";
\[Theta]rq::argerr="Expected one quaternion argument; instead got `1`.";
vrq::argerr="Expected one quaternion argument; instead got `1`.";
\[Theta]vrq::argerr="Expected one quaternion argument; instead got `1`.";
qv::argerr="Expected one, 3-vector argument; instead got `1`.";
rv::argerr="Expected a quaternion and a 3-vector argument; instead got `1`.";rf::argerr="Expected a quaternion and a 3-vector argument; instead got `1`.";


Begin["`Private`"];


(* :Code Section: *)


<<Quaternions`


rq[\[Theta]_?NumberQ,v_List]:=Quaternion[Cos[\[Theta]/2],Sequence@@(Sin[\[Theta]/2]Normalize[v])];
rq[\[Theta]_?NumberQ,x_?NumberQ,y_?NumberQ,z_?NumberQ]:=rq[\[Theta],{x,y,z}];
rq[args___]:=(Message[rq::argerr,{args}];$Failed);


ranv[]:=RandomReal[{-1,1},3];
ranv[args___]:=(Message[ranv::argerr,{args}];$Failed);


ran\[Theta][]:=RandomReal[{0,2\[Pi]}];
ran\[Theta][args___]:=(Message[ran\[Theta]::argerr,{args}];$Failed);


ranrq[]:=rq[RandomReal[2\[Pi]],ranv[]];
ranrq[args___]:=(Message[ranrq::argerr,{args}];$Failed);


rqw[w_List]:=rq[Norm[w],w];
rqw[args___]:=(Message[rqw::argerr,{args}];$Failed);


vq[q_Quaternion]:=List@@q[[2;;4]];
vq[args___]:=(Message[vq::argerr,{args}];$Failed);


wrq[rq_Quaternion]:=2ArcCos[rq[[1]]] Normalize @ vq @ rq;
wrq[args___]:=(Message[wrq::argerr,{args}];$Failed);


\[Theta]rq[rq_Quaternion]:=2ArcCos[rq[[1]]];
\[Theta]rq[args___]:=(Message[\[Theta]rq::argerr,{args}];$Failed);


vrq=vq;
vrq[args___]:=(Message[vrq::argerr,{args}];$Failed);


\[Theta]vrq[rq_Quaternion]:={\[Theta]rq[rq],vrq[rq]};
\[Theta]vrq[args___]:=(Message[\[Theta]vrq::argerr,{args}];$Failed);


qv[v_List]:=Quaternion[0,Sequence@@v];
qv[args___]:=(Message[qv::argerr,{args}];$Failed);


rv[rq_Quaternion,v_List]:=vq[rq**qv[v]**rq\[Conjugate]];
rv[args___]:=(Message[rv::argerr,{args}];$Failed);


rf[rq_Quaternion,v_List]:=vq[rq\[Conjugate]**qv[v]**rq];
rf[args___]:=(Message[rf::argerr,{args}];$Failed);


End[];


(* :Code Section (Call Protect): *)


Protect[rq,ranv,ran\[Theta],ranrq,rqw,vq,wrq,\[Theta]rq,vrq,\[Theta]vrq,qv,rv,rf];


EndPackage[];
