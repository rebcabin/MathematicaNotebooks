(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: RigidBodies *)
(* :Author: bbeckman *)
(* :Summary: Functions for rigid-body kinematics and dynamics. *)
(* :Context: Dzhanybekhov`RigidBodies` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 May 21 2014 *)
(* :Mathematica version: 9.0 for Mac OS X x86 (64-bit) (January 24, 2013) *)
(* :Discussion: Definitions and integrators for orientation quaternions, angular veloity, and angular-momentum vectors..*)(* :Discussion: Definitions and integrators for orientation quaternions, angular veloity, and angular-momentum vectors..*)
(* :Dependencies: Quaternions`, Dzhanybekhov`RotationQuaternions` *)


BeginPackage["Dzhanybekhov`RigidBodies`"];


(* :Code Section (Call Unprotect and ClearAll): *)


Unprotect[drqdt,d\[Omega]dt,rk4,rqn,\[Omega]n];
ClearAll[drqdt,d\[Omega]dt,rk4,rqn,\[Omega]n];


(* :Usage Messages: *)


(* :Code Section: *)


drqdt::usage=
"drqdt[rq,\[Omega]] produces the derivative of a rotation quaternion rq with respect to time given an angular-velocity vector \[Omega].";


d\[Omega]dt::usage="d\[Omega]dt[\[Omega],mi,mii] produces the derivative of an angular velocity \[Omega] with respect to time given a moment of inertia tensor mi and its inverse mii.";


rk4::usage="rk4[vt,v',dt,args...] produces a new value of a dynamic variable vt given a derivative function, v', which takes vt and ars as arguments, and a time inrement dt.";


rqn::usage="rqn[rq,\[Omega],dt] produces an incremental value for the rotation quaternion given a prior value rq, an angular velocity \[Omega] and a time increment dt.";


\[Omega]n::usage="\[Omega]n[\[Omega],mi,mii,dt] produces an incremental value for the angular velocity given a prior value \[Omega], a moment of inertia tensor mi, its inverse mii, and a time increment dt.";


(* :Error Messages: *)


(* :Code Section: *)


drqdt::argerr="Expected a quaternion and an angular velocity; instead got `1`.";


d\[Omega]dt::argerr="Expected an angular velocity, a moment-of-inertia matrix, and its inverse; instead got `1`.";


rk4::argerr=
"Expected a variable, function, time increment, and zero or more arguments; instead got `1`.";


rqn::argerr="Expected a quaternion, an angular velocity and a time increment; instead got `1`.";


\[Omega]n::argerr="Expected an angular velocity, a moment-of-inertia, its inverse, and a time increment; instead got `1`.";


Begin["`Private`"];


(* :Code Section: *)


<<Dzhanybekhov`RotationQuaternions`


drqdt[q_Quaternions`Quaternion,\[Omega]_List]:=1/2 q**qv[\[Omega]];
drqdt[args___]:=(Message[drqdt::argerr,{args}]);


d\[Omega]dt[\[Omega]nm1_List,mi_List,mii_List]:=mii.((mi.\[Omega]nm1)\[Cross]\[Omega]nm1);
d\[Omega]dt[args___]:=(Message[d\[Omega]dt::argerr,{args}]);


rk4[v_,vp_,dt_?NumberQ,args___]:=
With[{k1=dt*vp[v,Sequence@@{args}]},
With[{k2=dt*vp[v+k1/2,Sequence@@{args}]},
With[{k3=dt*vp[v+k2/2,Sequence@@{args}]},
With[{k4=dt*vp[v+k3,Sequence@@{args}]},
v+(k1+2k2+2k3+k4)/6]]]];
rk4[args___]:=(Message[rqn::argerr,{args}]);


rqn[rqnm1_Quaternions`Quaternion,\[Omega]nm1_List,dt_?NumberQ]:=
rk4[rqnm1,drqdt,dt,\[Omega]nm1];
rqn[args___]:=(Message[rqn::argerr,{args}]);


\[Omega]n[\[Omega]nm1_List,mi_List,mii_List,dt_?NumberQ]:=
rk4[\[Omega]nm1,d\[Omega]dt,dt,mi,mii];
\[Omega]n[args___]:=(Message[\[Omega]n::argerr,{args}]);


End[];


(* :Code Section (Call Protect): *)


Protect[drqdt,d\[Omega]dt,rk4,rqn,\[Omega]n];


EndPackage[];
