(***********************************************************************

                    Mathematica-Compatible Notebook

This notebook can be used on any computer system with Mathematica 4.0,
MathReader 4.0, or any compatible application. The data for the notebook 
starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do one of 
the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing the 
word CacheID, otherwise Mathematica-compatible applications may try to 
use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
***********************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[    185188,       6599]*)
(*NotebookOutlinePosition[    222987,       7859]*)
(*  CellTagsIndexPosition[    222943,       7855]*)
(*WindowFrame->Normal*)



Notebook[{
Cell[BoxData[
    StyleBox[\(Working\ with\ Unevaluated\ Expressions\),
      "Title"]], "Input"],

Cell["\<\
Robby Villegas
Wolfram Research\
\>", "Author",
  FontSize->14],

Cell[TextData[{
  "Abstract:\n\nMost experienced Mathematica programmers will eventually \
encounter tasks or applications in which they need to manipulate expressions \
without letting them evaluate. For instance, typesetting and interpretation \
rules, debugging programs, code analysis tools, and constructing code on the \
fly at run time are all areas of programming that require careful control of \
evaluation.  Since Mathematica automatically evaluates arguments and return \
values of functions, building up a result without exposing intermediate \
stages of work to the evaluator requires subtle techniques that even seasoned \
",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " programmers sometimes find elusive. In this tutorial, I will demonstrate \
situations in which evaluation control is important, pointing out common \
pitfalls and providing useful tools and techniques along the way."
}], "Abstract",
  FontSize->14],

Cell[BoxData[{
    \(Off[General::spell, \ General::spell1]\[IndentingNewLine]\), "\n", 
    \(Get["\<init.m\>"]\)}], "Input",
  InitializationCell->True],

Cell[CellGroupData[{

Cell["An Introduction to demystify scary things", "Section"],

Cell[CellGroupData[{

Cell["The overarching evaluator", "Subsubsection"],

Cell[TextData[{
  "   ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " is an interpreted language.  When ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " sees an input like this:\n\n",
  StyleBox["  f[1 + 2, 3^3, x + x + 0]", "Input",
    FontSize->12],
  "\n\nits standard procedure is to pre-evaluate the head f and the arguments \
ei before actually invoking the function f.  Thus, by the time the code for \
the function f is called, it sees this:\n\n",
  StyleBox["  f[3, 9, 2 x]", "Input",
    FontSize->12],
  "\n\nIt is the overarching ",
  StyleBox["evaluator",
    FontVariations->{"Underline"->True}],
  " that pre-processes the general form of expressions in this way."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[TextData[{
  "The reason ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " pre-evaluates is that it's usually what you want, in order to make \
interactive use or programming easier.  For instance, if you previously \
assigned a, b, and n values, you definitely want them substituted in before \
this the ",
  StyleBox["Expand", "Input",
    FontSize->12],
  " function is called here:"
}], "Text"],

Cell[BoxData[{
    \(ClearAll["\<a\>", \ "\<b\>", \ "\<n\>"]\[IndentingNewLine]\), "\n", 
    \({a, \ b}\  = \ {3, \ 7}; \), "\n", 
    \(n\  = \ 7; \)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Expand[\((a\ x\  + \ b\ y)\)^n]\)], "Input"],

Cell[BoxData[
    \(2187\ x\^7 + 35721\ x\^6\ y + 250047\ x\^5\ y\^2 + 972405\ x\^4\ y\^3 + 
      2268945\ x\^3\ y\^4 + 3176523\ x\^2\ y\^5 + 2470629\ x\ y\^6 + 
      823543\ y\^7\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "And in this example, you want the ",
  StyleBox["D", "Input",
    FontSize->12],
  " to compute the derivative expression before ",
  StyleBox["Simplify", "Input",
    FontSize->12],
  " goes to work, since before ",
  StyleBox["D", "Input",
    FontSize->12],
  " produces an expression, there's really nothing to simplify:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Simplify[\ D[ArcSin[x], \ {x, \ 8}]\ ]\)], "Input"],

Cell[BoxData[
    \(\(315\ x\ \((35 + 210\ x\^2 + 168\ x\^4 + 16\ x\^6)\)\)\/\((1 - x\^2)\)\
\^\(15/2\)\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "If Simplify acted on its literal argument, ",
  StyleBox["D[ArcSin[x], {x, 8}]", "Input",
    FontSize->12],
  ", what could it try to simplify?  ArcSin[x]?  x?  8??  That would not make \
sense, so the argument evaluates first, then the outer function is called."
}], "Text"],

Cell[TextData[{
  "So, in general, before f is actually called, there are ",
  StyleBox["two stages of your input",
    FontVariations->{"Underline"->True}],
  ".  Here they are using the generic form from earlier:\n\n(Before)",
  StyleBox["  f[1 + 2, 3^3, x + x + 0]\n  ", "Input",
    FontSize->12],
  "\n(After)",
  StyleBox["  f[3, 9, 2 x]", "Input",
    FontSize->12],
  "\n\nThe first stage is your original input before the evaluator gets its \
hands on it.\nThe second stage has the head and arguments evaluated.\n\nIt is \
the second that actually calls f, so f never sees the original arguments like \
1 + 2, only the reduced arguments like 3!"
}], "Text",
  CellDingbat->None],

Cell[TextData[{
  "I usually think of the evaluator's pre-processing as applying the \
\"evaluator function\", call it eval(), to all the parts.  I colored the head \
red and the arguments blue to emphasize them.\n\n",
  StyleBox["  ", "Input",
    FontSize->12],
  StyleBox["f", "Input",
    FontSize->12,
    FontColor->RGBColor[1, 0, 0]],
  StyleBox["[", "Input",
    FontSize->12],
  StyleBox["e1", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox[", ..., ", "Input",
    FontSize->12],
  StyleBox["en", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox["]\n  \n     ", "Input",
    FontSize->12],
  Cell[BoxData[
      FormBox[
        StyleBox["\[DoubleLongRightArrow]",
          SpanMinSize->4,
          SpanMaxSize->4], TraditionalForm]]],
  StyleBox["\n     ", "Input",
    FontSize->12],
  "\n",
  StyleBox["  eval(", "Input",
    FontSize->12],
  StyleBox["f", "Input",
    FontSize->12,
    FontColor->RGBColor[1, 0, 0]],
  StyleBox[") [ eval(", "Input",
    FontSize->12],
  StyleBox["e1", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox["), ..., eval(", "Input",
    FontSize->12],
  StyleBox["en", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox[") ]\n", "Input",
    FontSize->12],
  "\nFor those of you familiar with the evaluation sequence in Appendix \
\"A.4.1 The Standard Evaluation Sequence\" of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " book, I'm talking about steps 2 through 4, usually called \"standard \
argument evaluation\"."
}], "Text",
  CellDingbat->None],

Cell["\<\
   Here's a contrived example to show that simple arithmetic \
reduces the head and argument to sensible values.  Again, I've colored the \
head and argument, and made the function brackets large, to make it clear \
that this example is really of the simple form f[x], with f and x being sort \
of weird, complex things:\
\>", "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{
      StyleBox[\((1*FactorInteger\  + \ 0)\),
        FontColor->RGBColor[1, 0, 0]], "  ", 
      StyleBox["[",
        SpanMinSize->3,
        SpanMaxSize->3], " ", 
      StyleBox[\(2^2\ *\ 3^3\),
        FontColor->RGBColor[0, 0, 1]], " ", 
      StyleBox["]",
        SpanMinSize->3,
        SpanMaxSize->3]}]], "Input"],

Cell[BoxData[
    \({{2, 2}, {3, 3}}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["Trace", "Input",
    FontSize->12],
  " seems like a scary function, but you can use it in this case to catch the \
evaluation of head and argument, and see that it results in a nice, simple ",
  StyleBox["FactorInteger[108]", "Input",
    FontSize->12],
  ", which is then evaluated.  I've taken the liberty of arranging the ",
  StyleBox["Trace", "Input",
    FontSize->12],
  " result in a column and coloring the head and argument evaluations just as \
above to make it clear what each evaluation chain is."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{"Trace", "[", " ", 
      RowBox[{
        StyleBox[\((1*FactorInteger\  + \ 0)\),
          FontColor->RGBColor[1, 0, 0]], "  ", 
        StyleBox["[",
          SpanMinSize->3,
          SpanMaxSize->3], " ", 
        StyleBox[\(2^2\ *\ 3^3\),
          FontColor->RGBColor[0, 0, 1]], " ", 
        StyleBox["]",
          SpanMinSize->3,
          SpanMaxSize->3]}], 
      StyleBox[" ",
        SpanMinSize->3,
        SpanMaxSize->3], "]"}]], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {
            StyleBox[
              RowBox[{"{", 
                RowBox[{
                  RowBox[{"{", 
                    RowBox[{
                      TagBox[\(1\ FactorInteger\),
                        HoldForm], ",", 
                      TagBox["FactorInteger",
                        HoldForm]}], "}"}], ",", 
                  TagBox[\(FactorInteger + 0\),
                    HoldForm], ",", 
                  TagBox["FactorInteger",
                    HoldForm]}], "}"}],
              FontWeight->"Bold",
              FontColor->RGBColor[1, 0, 0]]},
          {
            StyleBox[
              RowBox[{"{", 
                RowBox[{
                  RowBox[{"{", 
                    RowBox[{
                      TagBox[\(2\^2\),
                        HoldForm], ",", 
                      TagBox["4",
                        HoldForm]}], "}"}], ",", 
                  RowBox[{"{", 
                    RowBox[{
                      TagBox[\(3\^3\),
                        HoldForm], ",", 
                      TagBox["27",
                        HoldForm]}], "}"}], ",", 
                  TagBox[\(4\ 27\),
                    HoldForm], ",", 
                  TagBox["108",
                    HoldForm]}], "}"}],
              FontWeight->"Bold",
              FontColor->RGBColor[0, 0, 1]]},
          {
            TagBox[
              StyleBox[\(FactorInteger[108]\),
                FontWeight->"Bold"],
              HoldForm]},
          {
            TagBox[\({{2, 2}, {3, 3}}\),
              HoldForm]}
          },
        GridBaseline->Top,
        RowSpacings->3],
      Grid]], "Output",
  CellEditDuplicate->False,
  GridBoxOptions->{ColumnAlignments->{Left}}]
}, Open  ]],

Cell[TextData[{
  StyleBox["\nThe point of this is to get you thinking of each input, and \
each statement in your programs, as having two stages:  the original stage \
that you typed (or constructed), and the reduced stage where arguments have \
been evaluated.  And to remember that the function isn't called until the \
second stage, so it ",
    FontVariations->{"Underline"->True}],
  StyleBox["doesn't know",
    FontSlant->"Italic",
    FontVariations->{"Underline"->True}],
  StyleBox[" what the original form was.\n",
    FontVariations->{"Underline"->True}]
}], "Text",
  FontSize->16,
  FontWeight->"Bold"],

Cell[TextData[{
  "   There are cases where you really want f to receive the arguments as \
given by the user or the programmer, not the pre-processed, i.e. evaluated, \
form.  Since the default behavior of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " language interpreter is to evaluate everything in sight until nothing \
more changes, you need to use non-default techniques to prevent evaluation.\n\
\nSometimes you want to send an argument into the function unevaluated.  For \
instance, when typesetting, or analyzing some code, you might want to compute \
",
  StyleBox["Length", "Input",
    FontSize->12],
  " of the expression ",
  StyleBox["Print[1, 2, 3]", "Input",
    FontSize->12],
  ", or use ",
  StyleBox["Cases", "Input",
    FontSize->12],
  " to extract the numbers from the mixed sum ",
  StyleBox["1 + 3.5 + Pi + x + (3 - I)^2", "Input",
    FontSize->12],
  ".\n\nSometimes you want the return value of the function to remain \
unevaluated until you can do something else with it.\n\nThat is the subject \
of this talk."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell["\<\


\
\>", "Text",
  CellDingbat->None],

Cell[TextData[{
  "Advanced note:  As you may know, in addition to evaluating head and \
arguments, the evaluator does other pre-processing to the original input, \
such as flatten ",
  StyleBox["Sequence,", "Input",
    FontSize->12],
  " and invoke upvalues on arguments.  These things can all alter the \
original input before the main function ever gets called.  You might want to \
prevent some or all of these alterations."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
An unevaluated expression is just an expression, a tree structure \
like anything else.\
\>", "Subsubsection"],

Cell["\<\
Before we start, I want to mention that an \"unevaluated\" \
expression is just an expression.  It's a tree structure that you can draw \
and see with your eyes:\
\>", "Text"],

Cell[BoxData[
    \(Plus[3, \ 4, \ Times[5, \ 6], \ Power[5, \ 2]]\)], "Input"],

Cell[TextData[{
  "For a moment, let yourself forget that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " would yank this expression out of your hands and give you back the \
integer 62.  Imagine that you can manipulate it as an ",
  StyleBox["abstract structure",
    FontSlant->"Italic"],
  " whose heads and elements are meaningless.  That's what you're going to \
learn to do in this talk.\n\nSince this expression is structurally the same \
as more stable ones like {3, 4, {5, 6}, {5, 2}}, programming commands that \
you are familiar with can operate on it, as long as you can see to it that \
the expression arrives unaltered at the code of the function.\n\nThere's \
nothing scary about operating on these; it's just a little harder to keep the \
evaluator's hands off them for a moment until you're ready for them to \
evaluate."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Simple uses of Unevaluated", "Subsubsection"],

Cell[TextData[{
  "Let's look at some simple uses of ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " is a wrapper on arguments that is simply a signal to the evaluator to \
avoid evaluating the argument."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head[\ Unevaluated[Plus[1, \ 2, \ 3]]\ ]\)], "Input"],

Cell[BoxData[
    \(Plus\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Length[\ 
      Unevaluated[Print["\<spam\>", \ "\<and\>", "\<eggs\>"]]\ ]\)], "Input"],

Cell[BoxData[
    \(3\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ToString[\ Unevaluated[2^2\ *\ 3^3\ *\ 5^5]\ ]\)], "Input"],

Cell[BoxData[
    \(" 2  3  5\n2  3  5"\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[
      Unevaluated[
        1 + 3.5 + Pi + 
          x + \((3 - 
                I)\)^2], \ _Integer\  | \ _Rational\  | \ _Real]\)], "Input"],

Cell[BoxData[
    \({1, 3.5`}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "It is ",
  StyleBox["transparent",
    FontSlant->"Italic"],
  " to the function receiving the argument.  You can think of it as a shuttle \
giving the argument safe transport to the function's code, keeping the \
evaluator away.  ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " vanishes before the argument is fed to the function, since its purpose is \
fulfilled."
}], "Text"],

Cell["Mapping a function across an unevaluated list of elements:", "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
    \({x, \ y, \ z}\  = \ {77, \ 88, \ 99}; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[Context, \ Unevaluated[{x, \ y, \ z}]\ ]\)], "Input"],

Cell[BoxData[
    \({"Global`", "Global`", "Global`"}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Without the ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ", the x, y, and z would become integers before ",
  StyleBox["Context", "Input",
    FontSize->12],
  " could act on them:"
}], "Text",
  CellDingbat->None],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[Context, \ {x, \ y, \ z}\ ]\)], "Input"],

Cell[BoxData[
    \(Context::"ssle" \(\(:\)\(\ \)\) 
      "Symbol, string, or HoldPattern[symbol] expected at position \!\(1\) in \
\!\(Context[77]\)."\)], "Message"],

Cell[BoxData[
    \(Context::"ssle" \(\(:\)\(\ \)\) 
      "Symbol, string, or HoldPattern[symbol] expected at position \!\(1\) in \
\!\(Context[88]\)."\)], "Message"],

Cell[BoxData[
    \(Context::"ssle" \(\(:\)\(\ \)\) 
      "Symbol, string, or HoldPattern[symbol] expected at position \!\(1\) in \
\!\(Context[99]\)."\)], "Message"],

Cell[BoxData[
    \(General::"stop" \(\(:\)\(\ \)\) 
      "Further output of \!\(Context :: \"ssle\"\) will be suppressed during \
this calculation."\)], "Message"],

Cell[BoxData[
    \({Context[77], Context[88], Context[99]}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Scan[Information, \ 
      Unevaluated[{$Version, \ $RecursionLimit}]]\)], "Input"],

Cell[BoxData[
    \("$Version is a string that represents the version of Mathematica you \
are running."\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[$Version] = {Locked, Protected}\)},
          {" "},
          {GridBox[{
                {\($Version = "4.0 for Linux (September 21, 1999)"\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ $Version],
      Editable->False]], "Print"],

Cell[BoxData[
    \("$RecursionLimit gives the current limit on the number of levels of \
recursion that Mathematica can use."\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\($RecursionLimit = 1024\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ $RecursionLimit],
      Editable->False]], "Print"]
}, Open  ]],

Cell[TextData[{
  "If you've got a set of things inside ",
  StyleBox["Hold", "Input",
    FontSize->12],
  ", and you want to map a non-holding function such as ",
  StyleBox["Head", "Input",
    FontSize->12],
  " across them, then you can use the idiom:\n\n",
  StyleBox["   f /@ Unevaluated /@ Hold[e1, ..., en]", "Input",
    FontSize->12],
  "\n\nwhich will form this frozen expression, with the calls to f colored in \
blue:\n\n",
  StyleBox["   Hold[ ", "Input",
    FontSize->12],
  StyleBox["f[Unevaluated[e1]]", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox[", ..., ", "Input",
    FontSize->12],
  StyleBox["f[Unevaluated[en]]", "Input",
    FontSize->12,
    FontColor->RGBColor[0, 0, 1]],
  StyleBox[" ]", "Input",
    FontSize->12],
  "\n\nNow it is safe to let the elements evaluate.  You could do this by \
changing the outer head to List.  Here is a small example:"
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
    \(List\  @@ \[IndentingNewLine]Map[Head, \ 
        Map[Unevaluated, \[IndentingNewLine]Hold[Print[1], \ 
            2\  + \ 3]\[IndentingNewLine]]]\)], "Input"],

Cell[BoxData[
    \({Print, Plus}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "You can use the more complex structural and functional programming \
commands that you enjoy, too.  They don't care that the argument arrives \
unevaluated; it's just a structure to them.  Here's an example of ",
  StyleBox["Through", "Input",
    FontSize->12],
  ", to produce a list of all the kinds of assignments made to a symbol:"
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
    \($ValueTypes = {Attributes, DefaultValues, DownValues, FormatValues, 
        Messages, NValues, OwnValues, Options, SubValues, 
        UpValues}; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? \ $Version\)], "Input"],

Cell[BoxData[
    \("$Version is a string that represents the version of Mathematica you \
are running."\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[$Version] = {Locked, Protected}\)},
          {" "},
          {GridBox[{
                {\($Version = "4.0 for Linux (September 21, 1999)"\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ $Version],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Through[\ $ValueTypes[Unevaluated[$Version]]\ ]\)], "Input"],

Cell[BoxData[
    \({{Locked, 
        Protected}, {}, {}, {}, {HoldPattern[$Version::"usage"] \
\[RuleDelayed] 
          "$Version is a string that represents the version of Mathematica \
you are running."}, {}, {HoldPattern[$Version] \[RuleDelayed] 
          "4.0 for Linux (September 21, 1999)"}, {}, {}, {}}\)], "Output"]
}, Open  ]],

Cell["\<\
It's easier to read if we make a match-up and display it as a \
column:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[$ValueTypes\  \[Rule] \ 
          Through[$ValueTypes\ @\ Unevaluated[$Version]]]\  // 
      ColumnForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes \[Rule] {Locked, Protected}\)},
          {\(DefaultValues \[Rule] {}\)},
          {\(DownValues \[Rule] {}\)},
          {\(FormatValues \[Rule] {}\)},
          {\(Messages \[Rule] {HoldPattern[$Version::"usage"] \[RuleDelayed] 
                  "$Version is a string that represents the version of \
Mathematica you are running."}\)},
          {\(NValues \[Rule] {}\)},
          {\(OwnValues \[Rule] {HoldPattern[$Version] \[RuleDelayed] 
                  "4.0 for Linux (September 21, 1999)"}\)},
          {\(Options \[Rule] {}\)},
          {\(SubValues \[Rule] {}\)},
          {\(UpValues \[Rule] {}\)}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      ColumnForm[ {Attributes -> {Locked, Protected}, DefaultValues -> {}, 
        DownValues -> {}, FormatValues -> {}, Messages -> {HoldPattern[ 
          MessageName[ $Version, "usage"]] :> 
        "$Version is a string that represents the version of Mathematica you \
are running."}, NValues -> {}, OwnValues -> {HoldPattern[ $Version] :> 
        "4.0 for Linux (September 21, 1999)"}, Options -> {}, SubValues -> {},
         UpValues -> {}}],
      Editable->False]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Unevaluated must be wrapper ",
  StyleBox["before argument evaluation",
    FontSlant->"Italic"],
  ", not after, else it isn't stripped"
}], "Subsubsection"],

Cell[TextData[{
  "Recall our discussion of the over-arching evaluator, and the fact that \
your inputs and commands have two stages:  their original form, and the \
reduced form with arguments all evaluated.\n\n",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " is not meant to be a function or stable data type.  It is to be used as a \
wrapper on an argument ",
  StyleBox["in stage 1",
    FontSlant->"Italic"],
  ", before argument evaluation.  It is a ",
  StyleBox["signal to the evaluator",
    FontSlant->"Italic"],
  " to suppress the usual evaluation of that argument.\n\n",
  StyleBox["   f[1, Unevaluated[2 + 2^2], 3]", "Input",
    FontSize->12],
  "\n\nOnce the evaluator has made a note not to evaluate that argument, ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  "'s purpose is fulfilled, so it vanishes before the argument is actually \
fed to f.  This is in contrast to ",
  StyleBox["Hold", "Input",
    FontSize->12],
  ", which is an actual data type, if you will, and persists as a head until \
you discard it (with ",
  StyleBox["ReleaseHold", "Input",
    FontSize->12],
  " or however you like)."
}], "Text"],

Cell[TextData[{
  "For instance, I can extract the head of a sum and get ",
  StyleBox["Plus", "Input",
    FontSize->12],
  ", as I expect:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head[\ Unevaluated[1 + 3.5 + Pi + x + \((3 - I)\)^2]\ ]\)], "Input"],

Cell[BoxData[
    \(Plus\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "But if I had used ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " instead of ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ", it would not have worked right:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head[\ Hold[1 + 3.5 + Pi + x + \((3 - I)\)^2]\ ]\)], "Input"],

Cell[BoxData[
    \(Hold\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Those of you who have experimented with ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " have found that in some situations it doesn't vanish.  This makes it seem \
confusing and inconsistent, like ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  ".\n\nThe least confusing situation where ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " persists is when it is the outermost head in the output.  This is not too \
surprising, since it's not an argument of anything."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Unevaluated[\ Print[1]\ /\ 2^3\ ]\)], "Input"],

Cell[BoxData[
    \(Unevaluated[Print[1]\/2\^3]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Another case where ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " is when it's an argument of a head that does nothing.  List is an example \
of an inert data type that performs no action:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({1, \ Unevaluated[2^2]}\)], "Input"],

Cell[BoxData[
    \({1, Unevaluated[2\^2]}\)], "Output"]
}, Open  ]],

Cell["So is an arbitrary symbol with no definitions:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[Unevaluated[1\  + \ 0], \ 2]\)], "Input"],

Cell[BoxData[
    \(f[Unevaluated[1 + 0], 2]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "When no code is invoked to \"use it up\", ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " just sits there unused."
}], "Text"],

Cell[TextData[{
  "\nThe subtle and confusing situation where ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " persists is when an argument did not originally have a head of ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ", but became ",
  StyleBox["Unevaluated[whatever]", "Input",
    FontSize->12],
  " after argument evaluation finished.  In terms of the two stages of each \
input:\n\nstage 1 (original input):  ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " vanishes, nicely.\n\nstage 2 (after arg evaluation):  ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " persists, annoyingly."
}], "Text"],

Cell[TextData[{
  "In this example, the original argument of ",
  StyleBox["Print", "Input",
    FontSize->12],
  " has head ",
  StyleBox["ToExpression", "Input",
    FontSize->12],
  ".  ",
  StyleBox["ToExpression", "Input",
    FontSize->12],
  " yields ",
  StyleBox["Unevaluated[1 + 2]", "Input",
    FontSize->12],
  " after evaluation, but that's too late:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Print[\ ToExpression["\<Unevaluated[1 + 2]\>"]\ ]\)], "Input"],

Cell[BoxData[
    \(Unevaluated[1 + 2]\)], "Print"]
}, Open  ]],

Cell["\<\
In this example, the argument's original head is a complex \
Function[...] expression, not even a symbol.  It yields Unevaluated[77 + \
99^2], but again\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{"Head", "[", " ", 
      StyleBox[\(\(Unevaluated[#1\  + \ #2^2] &\)\ [77, \ 99]\),
        "Input",
        FontSize->12], 
      StyleBox[" ",
        "Input",
        FontSize->12], 
      StyleBox["]",
        "Input",
        FontSize->12]}]], "Input"],

Cell[BoxData[
    \(Unevaluated\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "If I give an argument which, ",
  StyleBox["after evaluation",
    FontSlant->"Italic"],
  ", will become something whose head is ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " - ",
  StyleBox["Unevaluated[arg]", "Input",
    FontSize->12],
  " - and it won't work.\n\nThis subtle distinction of stages of your input \
has tripped up almost every ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " programmer I know, no matter how advanced."
}], "Text"],

Cell[TextData[{
  "Since in real programs, you often have to construct the arguments from \
pieces, and can't just write them out in final form in the function call, \
we'll have to learn methods of making sure the ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " is literally present as a wrapper in the function call."
}], "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Several specific techniques", "Section"],

Cell[CellGroupData[{

Cell["Manipulations", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Use Function[] to make a temporary holding version of a \
function\
\>", "Subsubsection"],

Cell[TextData[{
  "Most built-in and user-defined functions let their arguments evaluate by \
default.  Suppose for a particular line of code, you need a version of ",
  StyleBox["Head", "Input",
    FontSize->12],
  " that doesn't evaluate its arguments.  One way, of course, would be to \
temporarily give ",
  StyleBox["Head", "Input",
    FontSize->12],
  " the ",
  StyleBox["HoldFirst", "Input",
    FontSize->12],
  " attribute, but it's usually unsafe to change the definition of basic \
built-in functions.  Fortunately, the language enables you to give pure \
functions the same attributes you would give to symbols.  Here is the \
template for constructing a temporary holding version:\n\n",
  StyleBox["  ", "Input",
    FontSize->12],
  Cell[BoxData[
      \(MyHead\  = \ Function[e, \ Head[\ Unevaluated[e]\ ], \ HoldFirst]\)], 
    "Input",
    FontSize->12],
  "\n\nThis is essentially the same as the more familiar, simpler pure \
function\n\n",
  StyleBox["  MyHead = Head[#]&", "Input",
    FontSize->12],
  "\n\nbut it has to use the 3-argument form of ",
  StyleBox["Function", "Input",
    FontSize->12],
  " with a named variable in order to give it the ",
  StyleBox["HoldFirst", "Input",
    FontSize->12],
  " attribute."
}], "Text"],

Cell[TextData[{
  "Now you can use ",
  StyleBox["MyHead", "Input",
    FontSize->12],
  " just like you would use ",
  StyleBox["Head", "Input",
    FontSize->12],
  ".  If the argument comes in unevaluated, it will remain that way.  For \
instance:"
}], "Text"],

Cell[BoxData[
    \(MyHead\  = \ 
      Function[e, \ Head[\ Unevaluated[e]\ ], \ HoldFirst]; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MyHead\  /@ \ 
      Unevaluated[{Print[1], \ 2\  + \ 2^2, \ x\  = \ 3}]\)], "Input"],

Cell[BoxData[
    \({Print, Plus, Set}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "There's no need to give the function a name; I just did that to make the \
example more concise.  Usually you use ",
  StyleBox["Function[]", "Input",
    FontSize->12],
  " because you want to construct one-shot operators on the fly, to use in a \
single line of code."
}], "Text"],

Cell["Here's an example of a held list of elements:", "Text"],

Cell[BoxData[
    \(heldElems\  = \ 
      Hold[Print[1], \ Print[2\  + \ 3], \ 0\  + \ 1, \ 1\  + \ 2, \ 
        2\  + \ 3, \ 0*1, \ 1*2*3, \ 4^4]; \)], "Input"],

Cell[TextData[{
  "We want to group consecutive elements if they have the same head, i.e.\n\n\
",
  StyleBox["  ", "Input",
    FontSize->12],
  StyleBox["Head[#1] === Head[#2] &", "Input",
    FontSize->12],
  "\n\nBut this ordinary form of pure function will evaluate #1 and #2, which \
will destroy the structure in things like ",
  StyleBox["Print[1]", "Input",
    FontSize->12],
  " and ",
  StyleBox["0 + 1", "Input",
    FontSize->12],
  ", so we have to prevent that.  We do it by converting that function to the \
longer form:\n\n",
  StyleBox["  Function[{e1, e2}, Head[Unevaluated[e1]] === \
Head[Unevaluated[e2]], HoldAll]\n", "Input",
    FontSize->12],
  "\nAgain, it's essentially the same as the more familiar form, but it gives \
this construct the ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " attribute.  Here is the result in action:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Split[\[IndentingNewLine]\[IndentingNewLine]Hold[Print[1], \ 
        Print[2\  + \ 3], \ 0\  + \ 1, \ 1\  + \ 2, \ 2\  + \ 3, \ 0*1, \ 
        1*2*3, \ 4^4], \[IndentingNewLine]\[IndentingNewLine]Function[{e1, \ 
          e2}, \ Head[Unevaluated[e1]]\  === \ Head[Unevaluated[e2]], \ 
        HoldAll]\[IndentingNewLine]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(Hold[Hold[Print[1], Print[2 + 3]], Hold[0 + 1, 1 + 2, 2 + 3], 
      Hold[0\ 1, 2\ 3], Hold[4\^4]]\)], "Output"]
}, Open  ]],

Cell["\<\
And here is an example where you want to test unevaluated products \
to see if they contain spurious zeros:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[\[IndentingNewLine]Function[e, \ MemberQ[Unevaluated[e], \ 0], \ 
        HoldFirst], \[IndentingNewLine]Unevaluated[{x\ *\ y, \ 
          u\ *\ 0\ *\ v, \ 1\ *\ 2\ *\ 0}]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \({False, True, True}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "If you want to delete the zeros so that the products don't evaluate to \
zero, you can make a holding ",
  StyleBox["DeleteCases", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[\[IndentingNewLine]Function[e, \ 
        DeleteCases[Unevaluated[e], \ 0], \ 
        HoldFirst], \[IndentingNewLine]Unevaluated[{x\ *\ y, \ 
          u\ *\ 0\ *\ v, \ 1\ *\ 2\ *\ 0}]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \({x\ y, u\ v, 2}\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Replace is one of these easiest methods for transforming a \
structure, and it's sort of \"visual programming\", making it very clear to \
the reader what is happening.\
\>", "Subsubsection"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      Hold[1\  + \ 2, \ Print[3, \ 4], \ 
        D[x^2, \ x]], \[IndentingNewLine]h_[
          elems___]\  \[RuleDelayed] \ {h, \ 
          elems}, \[IndentingNewLine]{1}\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(Hold[{Plus, 1, 2}, {Print, 3, 4}, {D, x\^2, x}]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(patts\  = \ 
      Replace[Unevaluated[{1\  + \ 2, \ Print[3, \ 4], \ 
            D[x^2, \ x]}], \[IndentingNewLine]h_[___]\  \[RuleDelayed] \ 
          Blank[h], \[IndentingNewLine]{1}\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \({_Plus, _Print, _D}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Suppose I want to take the factored form of an integer and typeset it \
nicely as a product of prime powers.  Obviously, I can't let things like  ",
  Cell[BoxData[
      \(TraditionalForm\`3\^3\ 5\^5\)]],
  " evaluate before I feed it to the typesetting function, since then it \
would become some integer and I'd lose the decomposed form."
}], "Text"],

Cell[BoxData[
    \(n\  = \ 79301169838123235887500; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(factored\  = \ FactorInteger[n]\)], "Input"],

Cell[BoxData[
    \({{2, 2}, {3, 3}, {5, 5}, {7, 7}, {11, 11}}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "We're going to convert the inner lists to ",
  StyleBox["Power", "Input",
    FontSize->12],
  " and the outer list to ",
  StyleBox["Times", "Input",
    FontSize->12],
  ", so we need to have the ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " wrapper in place before we start:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(held\  = \ Hold[\ Evaluate[factored]\ ]\)], "Input"],

Cell[BoxData[
    \(Hold[{{2, 2}, {3, 3}, {5, 5}, {7, 7}, {11, 11}}]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "First, I convert each ordered pair {p, a} to the prime power that it \
represents:  ",
  Cell[BoxData[
      \(TraditionalForm\`p\^a\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      held, \[IndentingNewLine]{p_, \ a_}\  \[RuleDelayed] \ 
        p^a, \[IndentingNewLine]{2}\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(Hold[{2\^2, 3\^3, 5\^5, 7\^7, 11\^11}]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Now I change the list to a product and wrap a call to ",
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  " around it:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[%, \[IndentingNewLine]Hold[{elems___}]\  \[RuleDelayed] \ 
        MakeBoxes[Times[elems], \ 
          TraditionalForm]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(RowBox[{SuperscriptBox["2", "2"], " ", SuperscriptBox["3", "3"], " ", 
        SuperscriptBox["5", "5"], " ", SuperscriptBox["7", "7"], " ", 
        SuperscriptBox["11", "11"]}]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Once you've constructed a typeset box expression, you can use ",
  StyleBox["DisplayForm", "Input",
    FontSize->12],
  " to see how it would display if you sent it to a front end output cell:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DisplayForm[%]\)], "Input"],

Cell[BoxData[
    TagBox[\(2\^2\ 3\^3\ 5\^5\ 7\^7\ 11\^11\),
      DisplayForm]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Function and With can stuff values into any expression, including \
held ones.\
\>", "Subsubsection"],

Cell[TextData[{
  "Both ",
  StyleBox["With", "Input",
    FontSize->12],
  " and ",
  StyleBox["Function", "Input",
    FontSize->12],
  " do direct substitution into the body, and for the most part they're \
equivalent ways of \"filling in a template\", the body being the template:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(With[{p\  = \ 2, \ a\  = \ 2, \ q\  = \ 5, \ 
        b\  = \ 5}, \[IndentingNewLine]MakeBoxes[p^a\ *\ q^b]\  // 
        DisplayForm\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    TagBox[\(2\^2\ 5\^5\),
      DisplayForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(Function[{p, \ a, \ q, \ b}, \ 
        MakeBoxes[p^a\ *\ q^b]\  // DisplayForm]\)\ [2, \ 2, \ 5, \ 
      5]\)], "Input"],

Cell[BoxData[
    TagBox[\(2\^2\ 5\^5\),
      DisplayForm]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Why would you use ",
  StyleBox["With", "Input",
    FontSize->12],
  " or ",
  StyleBox["Function", "Input",
    FontSize->12],
  " to substitute in 2 and 5 when you could just type this?\n\n",
  StyleBox["  MakeBoxes[2^2 5^5]", "Input",
    FontSize->12],
  "\n\nAnswer:  p, a, q, and b are probably variables in a program you're \
writing, and you need to put their ",
  StyleBox["values",
    FontSlant->"Italic"],
  ", not their literal names, into the ",
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  " command.  You can't use ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  ", like this\n\n",
  StyleBox["  MakeBoxes[ Evaluate[p^a q^b] ]    (* does NOT work *)", "Input",
    
    FontSize->12],
  "\n\nbecause then the argument would collapse to an integer (besides, ",
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  " is ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " and doesn't respect ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  ").  You can't use ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " in deep subexpressions of a held argument, you can use it only on the \
whole argument\n\n",
  StyleBox["  MakeBoxes[ Evaluate[p]^Evaluate[a] * Evaluate[q]^Evaluate[b] ]  \
(* No *)", "Input",
    FontSize->12],
  "\n\nIn this situation, ",
  StyleBox["With", "Input",
    FontSize->12],
  " and ",
  StyleBox["Function", "Input",
    FontSize->12],
  " can jam those values in for you.  Since the initial values are probably \
those of variables in your program, here's an example of how you'd really use \
them in a program."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \({a, \ b, \ c}\  = \ {1, \ 2, \ 3}; \[IndentingNewLine]\), "\n", 
    \(With[{a\  = \ a, \ b\  = \ b, \ 
        c\  = \ c}, \[IndentingNewLine]MakeBoxes[a^b\  + \ c*a]\  // 
        DisplayForm\[IndentingNewLine]]\)}], "Input"],

Cell[BoxData[
    TagBox[\(1\^2 + 3\ 1\),
      DisplayForm]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Later, I'll show techniques for tagging arbitrary subexpressions for \
evaluation, in a function called ",
  StyleBox["EvaluateAt", "Input",
    FontSize->12],
  " (based on another new one called ",
  StyleBox["ReplaceAt", "Input",
    FontSize->12],
  ")."
}], "Text"],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
  "Something that you may not know is that ",
  StyleBox["With", "Input",
    FontSize->12],
  " initializations can use ':=' as well as '=', to cause the initialization \
not to evaluate.  For instance:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \({a, \ b, \ c}\  = \ {1, \ 2, \ 3}; \[IndentingNewLine]\), "\n", 
    \(With[{expr\  := \ a\  + \ b\  + \ c}, \[IndentingNewLine]{expr, \ 
        Length[Unevaluated[expr]]}\[IndentingNewLine]]\)}], "Input"],

Cell[BoxData[
    \({6, 3}\)], "Output"]
}, Open  ]],

Cell["\<\
It's true that if the local value of 'expr' is an unevaluated \
expression, then you could simply use that literal expression everywhere you \
need it instead of a local 'expr', but maybe it makes the code clearer if \
many places in a region of code all use exactly the same expression.  Some of \
them may need it unevaluated, some may be happy to let it evaluate.\
\>", \
"Text"],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
  StyleBox["Advanced note\n",
    FontVariations->{"Underline"->True}],
  "The initializations in scoping constructs ",
  StyleBox["Module", "Input",
    FontSize->12],
  " and ",
  StyleBox["With", "Input",
    FontSize->12],
  " are not ",
  StyleBox["evaluated as calls",
    FontSlant->"Italic"],
  " to the ",
  StyleBox["Set", "Input",
    FontSize->12],
  " or ",
  StyleBox["SetDelayed", "Input",
    FontSize->12],
  " functions.  You can see this by either attaching a top-level trap to ",
  StyleBox["Set", "Input",
    FontSize->12],
  ", or by using ",
  StyleBox["Block", "Input",
    FontSize->12],
  " to temporarily disable ",
  StyleBox["Set", "Input",
    FontSize->12],
  ".  Either way, you'll see that ",
  StyleBox["Module", "Input",
    FontSize->12],
  " and ",
  StyleBox["With", "Input",
    FontSize->12],
  " accomplish initializations in a magical internal way, not by calling the \
top-level ",
  StyleBox["Set", "Input",
    FontSize->12],
  " function.\n\nStrangely, if you ask ",
  StyleBox["Trace", "Input",
    FontSize->12],
  " to report ",
  StyleBox["Set", "Input",
    FontSize->12],
  " evaluation chains, it ",
  "will report",
  " local variable initializations!  My best guess is that since we specify \
initializations with something that is ",
  StyleBox["syntactically",
    FontSlant->"Italic"],
  " ",
  StyleBox["Set[var, value]", "Input",
    FontSize->12],
  ", the evaluation chain for initialization is considered to begin with the \
expression ",
  StyleBox["Set[var, value]", "Input",
    FontSize->12],
  ", and this is good enough to convince ",
  StyleBox["Trace", "Input",
    FontSize->12],
  " that it is a call to ",
  StyleBox["Set", "Input",
    FontSize->12],
  ", even though technically some internal magic intervenes and performs \
assignments instead of letting ",
  StyleBox["Set", "Input",
    FontSize->12],
  " do it.\n\nI was tempted to consider this a bug, but one advantage - a \
significant one for kernel hackers - is that you can actually trap ",
  StyleBox["Set", "Input",
    FontSize->12],
  " with the familiar idiom for trapping internal functions, and not get \
yourself into infinite recursion trouble when you do ",
  StyleBox["Block[{$TrapSet = False}, ...]", "Input",
    FontSize->12],
  ".  But it is an odd inconsistency in the language that you use the ",
  StyleBox["syntax",
    FontSlant->"Italic"],
  " ",
  StyleBox["Set[var, value]", "Input",
    FontSize->12],
  " to specify an action that will not be carried out by ",
  StyleBox["Set", "Input",
    FontSize->12],
  ", but by inaccessible internal magic."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Unprotect[Set]; \[IndentingNewLine]\), "\n", 
    \($TrapSet\  = \ True; \[IndentingNewLine]\), "\n", 
    \(assign_Set\  /; \ $TrapSet\  := \[IndentingNewLine]Block[{$TrapSet\  = \
\ False}, \[IndentingNewLine]Print\ @\ 
          Unevaluated[
            assign]; \[IndentingNewLine]assign\[IndentingNewLine]]\)}], \
"Input"],

Cell[BoxData[
    \($Line = 85\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Module[{x\  = \ 3}, \ x^2]\)], "Input"],

Cell[BoxData[
    \(9\)], "Output"],

Cell[BoxData[
    \($Line = 86\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{x\  = \ 3}, \ x]\)], "Input"],

Cell[BoxData[
    \(3\)], "Output"],

Cell[BoxData[
    \($Line = 87\)], "Print"]
}, Open  ]],

Cell[BoxData[
    \(assign_Set\  /; \ $TrapSet\  =. \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Set}, \[IndentingNewLine]Module[{x\  = \ 3}, \ u\  = \ 1; \ 
        x^2]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(9\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?\ u\)\)], "Input"],

Cell[BoxData[
    \("Global`u"\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Trace[Module[{x\  = \ 3}, x^2], Set, 
      TraceInternal \[Rule] True]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{"{", 
        RowBox[{
          TagBox[\(x$33 = 3\),
            HoldForm], ",", 
          TagBox["3",
            HoldForm]}], "}"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Build up the arguments inside of Hold, then apply the function at \
the end\
\>", "Subsubsection"],

Cell[TextData[{
  "Sometimes it takes several steps to go from the original input to the \
final arguments you want to pass to a function.  In this case, it's usually \
good to wrap the inputs in Hold at the beginning and work with them, then \
replace Hold with f at the end.  We saw this in the last section using \
Replace to make the result look more and more like what we want.  The final \
step is often one of these:\n\n",
  StyleBox["   f @@ Hold[e1, ..., en]\n   \n   ReleaseHold @ Hold[f[e1, ..., \
en]]", "Input",
    FontSize->12],
  "\n\nHere's an example where my function is given an integrand and the \
ranges of the variables.  A typical call will look like this:\n\n",
  StyleBox["  f[x + y + z, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]", "Input",
    FontSize->12],
  "\n\nBut I would like global values of the variables, if they should exist, \
not to interfere with computing this integral.  To prevent outside \
interference, you of course wrap the integral in Block with {x, y, z} local.  \
So I want to take the above and construct this expression:\n\n",
  StyleBox["  Block[{x, y, z},\n    Integrate[x + y + z, {x, -1, 1}, {y, -1, \
1}, {z, -1, 1}]\n  ]", "Input",
    FontSize->12],
  StyleBox["\n",
    FontSize->12],
  "\nThat looks awfully easy since I'm just wrapping a Block around the \
desired Integrate expression.\n\nBut remember that I don't know in advance \
what the variables are or how many there will be!  Here is the template for \
my function:\n\n",
  StyleBox["Attributes[f] = HoldAll;\n\nf[iterand_, iterSpecs:{_Symbol, \
__}...] := ...\n", "Input",
    FontSize->12],
  StyleBox["\n",
    FontSize->12],
  "Let's look at the steps in constructing the Block from the input, and not \
evaluating it until it's all assembled.  We'll give {x, y, z} values at the \
beginning, so that if we make a mistake and expose anything to the evaluator \
too early, we'll know."
}], "Text"],

Cell[BoxData[
    \({x, \ y, \ z}\  = \ {77, \ 88, \ 99}; \)], "Input"],

Cell["\<\
First wrap the iterSpecs in Hold so we can safely extract the \
variable names.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{"heldIterSpecs", " ", "=", " ", 
      RowBox[{"Hold", "[", 
        StyleBox[\({x, \ \(-1\), \ 1}, \ {y, \ \(-1\), \ 
            1}, \ {z, \ \(-1\), \ 1}\),
          "Input",
          FontSize->12], 
        StyleBox["]",
          "Input",
          FontSize->12]}]}]], "Input"],

Cell[BoxData[
    \(Hold[{x, \(-1\), 1}, {y, \(-1\), 1}, {z, \(-1\), 1}]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(heldVars\  = \ 
      Replace[heldIterSpecs, \ {s_Symbol, \ ___}\  \[RuleDelayed] \ 
          s, \ {1}]\)], "Input"],

Cell[BoxData[
    \(Hold[x, y, z]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(heldVarList\  = \ 
      Replace[heldVars, \ 
        Hold[elems___]\  \[RuleDelayed] \ Hold[{elems}]]\)], "Input"],

Cell[BoxData[
    \(Hold[{x, y, z}]\)], "Output"]
}, Open  ]],

Cell["\<\
This gives us argument 1 of Block, the local variable declaration.  \
Now we just need to append the body.  The body is simply Integrate[iterand, \
iterSpecs].  Those were the names of the pattern variables in f, so they'll \
get substituted directly in.  I write them out in my next input, since I'm in \
an interactive session, not inside my function body.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Append[heldVarList, \ 
      Unevaluated[\[IndentingNewLine]Integrate[
          x\  + \ y\  + \ z, \ {x, \ \(-1\), \ 1}, \ {y, \ \(-1\), \ 
            1}, \ {z, \ \(-1\), \ 1}]\[IndentingNewLine]]]\)], "Input"],

Cell[BoxData[
    \(Hold[{x, y, 
        z}, \[Integral]\_\(-1\)\%1\(\[Integral]\_\(-1\)\%1\(\[Integral]\_\(-1\
\)\%1\((x + y + 
                  z)\) \[DifferentialD]z \[DifferentialD]y \
\[DifferentialD]x\)\)]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block\  @@ \ %\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Open  ]],

Cell["\<\
Great, it works!  And we can see that it would have failed without \
our careful construction of Block:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Integrate[
      x\  + \ y\  + \ z, \ {x, \ \(-1\), \ 1}, \ {y, \ \(-1\), \ 
        1}, \ {z, \ \(-1\), \ 1}]\)], "Input"],

Cell[BoxData[
    \(Integrate::"ilim" \(\(:\)\(\ \)\) 
      "Invalid integration variable or limit(s) in \!\({77, \(\(-1\)\), 1}\) \
."\)], "Message"],

Cell[BoxData[
    \(\[Integral]\_\(-1\)\%1\(\[Integral]\_\(-1\)\%1\(\[Integral]\_\(-1\)\%1 
            264 \[DifferentialD]99 \[DifferentialD]88 \
\[DifferentialD]77\)\)\)], "Output"]
}, Open  ]],

Cell["Here it is all put together into a function:", "Text"],

Cell[BoxData[{
    StyleBox[\(\(Attributes[f]\  = \ HoldAll; \)\(\n\)\),
      "Input",
      FontSize->12], "\n", 
    RowBox[{
      StyleBox[\(f[iterand_, \ iterSpecs : {_Symbol, \ __} ... ]\),
        "Input",
        FontSize->12], 
      StyleBox[" ",
        "Input",
        FontSize->12], 
      StyleBox[":=",
        "Input",
        FontSize->12], "\[IndentingNewLine]", 
      "\[IndentingNewLine]", \(Module[{heldIterSpecs, \ heldVars, \ 
          heldVarList}, \[IndentingNewLine]\[IndentingNewLine]heldIterSpecs\  \
= \ Hold[iterSpecs]; \[IndentingNewLine]\[IndentingNewLine]heldVars\  = \ 
          Replace[heldIterSpecs, \ {s_Symbol, \ ___}\  \[RuleDelayed] \ 
              s, \ {1}]; \[IndentingNewLine]\[IndentingNewLine]heldVarList\  \
= \ Replace[heldVars, \ 
            Hold[elems___]\  \[RuleDelayed] \ 
              Hold[{elems}]]; \[IndentingNewLine]\[IndentingNewLine]Block\  \
@@ \ Append[heldVarList, \ 
            Unevaluated[\[IndentingNewLine]Integrate[iterand, \ 
                iterSpecs]\[IndentingNewLine]]]\[IndentingNewLine]]\)}]}], \
"Input"],

Cell["\<\
Here are some annoying assignments that will surely tell us if we \
evaluate anything:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({x, \ y, \ z}\  := \ {Print[1], \ Print[2], \ Print[3]}\)], "Input"],

Cell[BoxData[
    \({Null, Null, Null}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{
      StyleBox["f",
        "Input",
        FontSize->12], 
      StyleBox["[",
        "Input",
        FontSize->12], 
      RowBox[{\(x^2\  + \ y^2\  + \ y^2\), 
        StyleBox[",",
          "Input",
          FontSize->12], 
        StyleBox[" ",
          "Input",
          FontSize->12], 
        StyleBox[\({x, \ \(-1\), \ 1}\),
          "Input",
          FontSize->12], 
        StyleBox[",",
          "Input",
          FontSize->12], 
        StyleBox[" ",
          "Input",
          FontSize->12], 
        StyleBox[\({y, \ \(-1\), \ 1}\),
          "Input",
          FontSize->12], 
        StyleBox[",",
          "Input",
          FontSize->12], 
        StyleBox[" ",
          "Input",
          FontSize->12], 
        StyleBox[\({z, \ \(-1\), \ 1}\),
          "Input",
          FontSize->12]}], 
      StyleBox["]",
        "Input",
        FontSize->12]}]], "Input"],

Cell[BoxData[
    \(8\)], "Output"]
}, Open  ]],

Cell[BoxData[
    \(ClearAll["\<x\>", \ "\<y\>", \ "\<z\>"]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Construct a held result from parts", "Subsubsection"],

Cell["\<\
Sometimes it's fine for the inputs to evaluate, but the expression \
you construct from them must not evaluate.  When it's okay to evaluate the \
parts but not the whole, plain old pure functions are often quick and easy:\
\
\>", "Text"],

Cell[TextData[{
  "An assignment, on standby, waiting for ",
  StyleBox["ReleaseHold", "Input",
    FontSize->12],
  ", or to be typeset and used as the limit of a ",
  StyleBox["Sum", "Input",
    FontSize->12],
  ", or whatever:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(Hold[Set[x, \ #]] &\)\ [77]\)], "Input"],

Cell[BoxData[
    \(Hold[x = 77]\)], "Output"]
}, Open  ]],

Cell["A sum of numbers:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(Hold[Plus[##]] &\)\  @@ \ {6, \ 7.5, \ 8\  - \ 3\ I, \ 
        4/5}\)], "Input"],

Cell[BoxData[
    \(Hold[
      6 + \(\(7.5`\)\(\[InvisibleSpace]\)\) + \((8 - 3\ \[ImaginaryI])\) + 
        4\/5]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["Composition", "Input",
    FontSize->12],
  " is another form of anonymous function, too, but without #n and ##n \
variables:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Composition[HoldForm, \ Plus]\  @@ \ {6, \ 7.5, \ 8\  - \ 3\ I, \ 
        4/5}\)], "Input"],

Cell[BoxData[
    TagBox[\(6 + \(\(7.5`\)\(\[InvisibleSpace]\)\) + \((8 - 
            3\ \[ImaginaryI])\) + 4\/5\),
      HoldForm]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Wrap everything in a holding wrapper, do your manipulations, then \
finish with ReleaseHold.\
\>", "Subsubsection"],

Cell["\<\
Here I'll introduce HoldForm, which is cute because it holds just \
as Hold does, but it doesn't display itself.  Thus, you can see the \
essentials, instead of having the display crowded with Hold.  Of course, \
since you can't see HoldForm, you have to remember where you put it, so it \
can be deceptive.  You can use InputForm to reveal the HoldForm's, reminding \
yourself where they are.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(atomsHeld\  = \ 
      Map[HoldForm, \ Unevaluated[2^1\ *\ 3^2\ *\ 5^3], \ {\(-1\)}, \ 
        Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox["Times",
        HoldForm], "[", 
      RowBox[{
        RowBox[{
          TagBox["Power",
            HoldForm], "[", 
          RowBox[{
            TagBox["2",
              HoldForm], ",", 
            TagBox["1",
              HoldForm]}], "]"}], ",", 
        RowBox[{
          TagBox["Power",
            HoldForm], "[", 
          RowBox[{
            TagBox["3",
              HoldForm], ",", 
            TagBox["2",
              HoldForm]}], "]"}], ",", 
        RowBox[{
          TagBox["Power",
            HoldForm], "[", 
          RowBox[{
            TagBox["5",
              HoldForm], ",", 
            TagBox["3",
              HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[atomsHeld, \ HoldForm[Power]]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox["Power",
        HoldForm], "[", 
      RowBox[{
        RowBox[{
          TagBox["Times",
            HoldForm], "[", 
          RowBox[{
            TagBox["2",
              HoldForm], ",", 
            TagBox["3",
              HoldForm], ",", 
            TagBox["5",
              HoldForm]}], "]"}], ",", 
        RowBox[{
          TagBox["Times",
            HoldForm], "[", 
          RowBox[{
            TagBox["1",
              HoldForm], ",", 
            TagBox["2",
              HoldForm], ",", 
            TagBox["3",
              HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(%\  /. \ HoldForm[Power]\  \[Rule] \ HoldForm[Plus]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox["Plus",
        HoldForm], "[", 
      RowBox[{
        RowBox[{
          TagBox["Times",
            HoldForm], "[", 
          RowBox[{
            TagBox["2",
              HoldForm], ",", 
            TagBox["3",
              HoldForm], ",", 
            TagBox["5",
              HoldForm]}], "]"}], ",", 
        RowBox[{
          TagBox["Times",
            HoldForm], "[", 
          RowBox[{
            TagBox["1",
              HoldForm], ",", 
            TagBox["2",
              HoldForm], ",", 
            TagBox["3",
              HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ReleaseHold[%]\)], "Input"],

Cell[BoxData[
    \(36\)], "Output"]
}, Open  ]],

Cell["\<\
A nice alternative in a typesetting front end is to define yourself \
a wrapper that holds, just like Hold and HoldForm do, but which prints as a \
framebox or a colored background around its argument.  That way, it's not \
obtrusive, and yet it's visible so you don't forget it's there.  The \
typesetting rule is just two lines:\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll["\<HoldFormFrame\>"]\[IndentingNewLine]\), "\n", 
    \(Attributes[HoldFormFrame]\  = \ HoldAll; \[IndentingNewLine]\), "\n", 
    \(HoldFormFrame\  /: \ 
      MakeBoxes[HoldFormFrame[expr_], \ fmt_]\  := \[IndentingNewLine]TagBox[
        FrameBox\ @\ MakeBoxes[expr, \ fmt], \ 
        HoldFormFrame]\[IndentingNewLine]\), "\n", 
    \(HoldFormFrame\  /: \ 
      MakeBoxes[HoldFormFrame[expr_], \ fmt_]\  := \[IndentingNewLine]TagBox[
        FrameBox\ @\ MakeBoxes[expr, \ fmt], \ HoldFormFrame]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(atomsHeld\  = \ 
      Map[HoldFormFrame, \ Unevaluated[2^1\ *\ 3^2\ *\ 5^3], \ {\(-1\)}, \ 
        Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox[
        FrameBox["Times"],
        HoldFormFrame], "[", 
      RowBox[{
        RowBox[{
          TagBox[
            FrameBox["Power"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["2"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["1"],
              HoldFormFrame]}], "]"}], ",", 
        RowBox[{
          TagBox[
            FrameBox["Power"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["3"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["2"],
              HoldFormFrame]}], "]"}], ",", 
        RowBox[{
          TagBox[
            FrameBox["Power"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["5"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["3"],
              HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[atomsHeld, \ HoldFormFrame[Power]]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox[
        FrameBox["Power"],
        HoldFormFrame], "[", 
      RowBox[{
        RowBox[{
          TagBox[
            FrameBox["Times"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["2"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["3"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["5"],
              HoldFormFrame]}], "]"}], ",", 
        RowBox[{
          TagBox[
            FrameBox["Times"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["1"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["2"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["3"],
              HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(%\  /. \ 
      HoldFormFrame[Power]\  \[Rule] \ HoldFormFrame[Plus]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox[
        FrameBox["Plus"],
        HoldFormFrame], "[", 
      RowBox[{
        RowBox[{
          TagBox[
            FrameBox["Times"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["2"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["3"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["5"],
              HoldFormFrame]}], "]"}], ",", 
        RowBox[{
          TagBox[
            FrameBox["Times"],
            HoldFormFrame], "[", 
          RowBox[{
            TagBox[
              FrameBox["1"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["2"],
              HoldFormFrame], ",", 
            TagBox[
              FrameBox["3"],
              HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[%, \ HoldFormFrame, \ {\(-1\)}, \ 
      Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(36\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Replace function names with temporary dummy symbols", "Subsubsection"],

Cell["\<\
In this technique, you replace \"active\" built-in functions with \
inert symbols of your own choosing.  This gives you a meaningless data \
structure that you can perform structural transformations on.  When you \
achieve the structure you want, you restore the original built-in \
functions.\
\>", "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
    \(atomsHeld\  = \ 
      Unevaluated[2^1\ *\ 3^2\ *\ 5^3]\  /. \ {Times\  \[Rule] \ MyTimes, \ 
          Power\  \[Rule] \ MyPower}\)], "Input"],

Cell[BoxData[
    \(MyTimes[MyPower[2, 1], MyPower[3, 2], MyPower[5, 3]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[atomsHeld, \ MyPower]\)], "Input"],

Cell[BoxData[
    \(MyPower[MyTimes[2, 3, 5], MyTimes[1, 2, 3]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(%\  /. \ MyPower\  \[Rule] \ MyPlus\)], "Input"],

Cell[BoxData[
    \(MyPlus[MyTimes[2, 3, 5], MyTimes[1, 2, 3]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(%\  /. \ {MyPlus\  \[Rule] \ Plus, \ 
        MyTimes\  \[Rule] \ Times}\)], "Input"],

Cell[BoxData[
    \(36\)], "Output"]
}, Open  ]],

Cell["\<\
This is very similar to the previous technique of turning every \
atom into Hold[a], in that you preserve the original structure but replace \
\"active\" parts with inactive things, and then undo it at the end.  This one \
replaces only the vital heads, though, not all the atoms.\
\>", "Text"],

Cell[TextData[{
  "A more subtle way to do the same thing is to make ",
  StyleBox["Module", "Input",
    FontSize->12],
  " do the work for you.  You have to undo the change at the end, e.g. ",
  StyleBox["Plus$n -> Plus", "Input",
    FontSize->12],
  ", but that's easily done with this type of rule:\n\n",
  StyleBox["  Plus -> Symbol[\"Plus\"]", "Input",
    FontSize->12],
  StyleBox["\n",
    FontSize->12]
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
    \(atomsHeld\  = \[IndentingNewLine]Module[{Times, \ Power, \ Plus, \ 
          expr}, \[IndentingNewLine]expr\  = \ 
          2^1\ *\ 3^2\ *\ 5^3; \[IndentingNewLine]thread\  = \ 
          Thread[expr, \ Power]; \[IndentingNewLine]plus\  = \ 
          thread\  /. \ 
            Power\  \[Rule] \ 
              Plus; \[IndentingNewLine]plus\  /. \ {Plus\  \[Rule] \ 
              Symbol["\<Plus\>"], \ 
            Times\  \[Rule] \ 
              Symbol["\<Times\>"]}\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(36\)], "Output"]
}, Open  ]],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
  StyleBox["Advanced note",
    FontVariations->{"Underline"->True}],
  ":\nIf you like the ",
  StyleBox["Module", "Input",
    FontSize->12],
  " technique and are too lazy to write out the ",
  StyleBox["s -> Symbol[\"s\"]", "Input",
    FontSize->12],
  " rules, or if you're using generated code and must compute those rules \
rather than type them in, here is a way to automate the ",
  StyleBox["x$n -> x", "Input",
    FontSize->12],
  " rules.  It uses a slight hack:  you declare an extra local variable in \
the ",
  StyleBox["Module", "Input"],
  ", which remains unused except for being passed to the function that \
creates the ",
  StyleBox["x$n -> x", "Input"],
  " rules.  The reason it is so passed is to provide the value of n.  You \
can't use assume that ",
  StyleBox["$ModuleNumber", "Input"],
  " will have the value you want at the end of the main ",
  StyleBox["Module", "Input"],
  ", since functions called during execution of the ",
  StyleBox["Module", "Input"],
  "'s body may have had module's themselves, hence increasing ",
  StyleBox["$ModuleNumber", "Input"],
  " beyond its original value."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
    RowBox[{\(UndoModuloLocals[sampleSym_Symbol]\), " ", ":=", 
      "\[IndentingNewLine]", 
      RowBox[{"Module", "[", 
        RowBox[{
          RowBox[{"{", 
            RowBox[{"sampleName", ",", " ", "suffix", 
              StyleBox[",",
                FontWeight->"Plain"], 
              StyleBox[" ",
                FontWeight->"Plain"], "suffixLen", ",", " ", "nameForm"}], 
            "}"}], ",", 
          "\[IndentingNewLine]", \(sampleName\  = \ 
            SymbolName\ @\ 
              Unevaluated[sampleSym]; \[IndentingNewLine]suffix\  = \ 
            StringTake[
              sampleName, \ {\(StringPosition[
                    sampleName, \ "\<$\>"]\)[\([\(-1\), \ 
                    1]\)], \ \(-1\)}]; \[IndentingNewLine]suffixLen\  = \ 
            StringLength[
              suffix]; \[IndentingNewLine]nameForm\  = \ "\<*\>"\  <> \ 
              suffix; \[IndentingNewLine]s_Symbol\  \[RuleDelayed] \ 
            With[{str\  = \ 
                  SymbolName\ @\ 
                    Unevaluated[s]}, \[IndentingNewLine]Symbol\ @\ 
                  StringDrop[str, \ \(-suffixLen\)]\  /; \ 
                StringMatchQ[str, \ nameForm]\[IndentingNewLine]]\)}], 
        "\[IndentingNewLine]", "]"}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Module[{Times, \ Power, \ Plus, \ expr, \ 
        sampleSym}, \[IndentingNewLine]expr\  = \ 
        2^1\ *\ 3^2\ *\ 5^3; \[IndentingNewLine]thread\  = \ 
        Thread[expr, \ Power]; \[IndentingNewLine]plus\  = \ 
        thread\  /. \ Power\  \[Rule] \ Plus; \[IndentingNewLine]plus\  /. \ 
        UndoModuloLocals[sampleSym]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(36\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Use Block to temporarily nullify built-in or user-defined functions\
\
\>", "Subsubsection"],

Cell[TextData[{
  "One of my favorite techniques is to use ",
  StyleBox["Block", "Input",
    FontSize->12],
  " to deactivate built-in functions for a while so I can safely work with \
expressions as meaningless structures.\n\nI don't do much mathematics myself, \
but one question at the Chicago 1998 conference was how to prevent a \
mathematical function, perhaps it was ",
  StyleBox["Integrate", "Input",
    FontSize->12],
  ", from acting until he had done some expanding, factoring, or other \
algebra on the arguments."
}], "Text"],

Cell["Suppose I have this integral:", "Text"],

Cell[BoxData[
    \(Clear[x, \ y]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Integrate[\((x\  + \ y)\)^3, \ x]\)], "Input"],

Cell[BoxData[
    \(1\/4\ \((x + y)\)\^4\)], "Output"]
}, Open  ]],

Cell["\<\
Now I decide I want to integrate the expanded form instead.  I can \
do it interactively in the front end by using the \"Evaluate In Place\" \
feature:\
\>", "Text"],

Cell[BoxData[
    RowBox[{"Integrate", "[", 
      RowBox[{
        StyleBox[\(Expand[\((x\  + \ y)\)^3]\),
          FontColor->RGBColor[0, 0, 1],
          Background->None], ",", " ", "x"}], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Integrate[x\^3 + 3\ x\^2\ y + 3\ x\ y\^2 + y\^3, \ x]\)], "Input"],

Cell[BoxData[
    \(x\^4\/4 + x\^3\ y + \(3\ x\^2\ y\^2\)\/2 + x\ y\^3\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "One way to do it programmatically is to deactive ",
  StyleBox["Integrate", "Input",
    FontSize->12],
  " long enough to apply transformations:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Integrate}, \[IndentingNewLine]int\  = \ 
        Integrate[\((x\  + \ y)\)^3, \ x]; \[IndentingNewLine]exp\  = \ 
        MapAt[Expand, \ int, \ 
          1]; \[IndentingNewLine]exp\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(x\^4\/4 + x\^3\ y + \(3\ x\^2\ y\^2\)\/2 + x\ y\^3\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "From the final form, it's obvious that it worked.  We could verify it by \
printing the intermediate expression while still in the ",
  StyleBox["Block", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Integrate}, \[IndentingNewLine]int\  = \ 
        Integrate[\((x\  + \ y)\)^3, \ x]; \[IndentingNewLine]exp\  = \ 
        MapAt[Expand, \ int, \ 1]; \[IndentingNewLine]Print["\<exp = \>", \ 
        exp]; \[IndentingNewLine]exp\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    InterpretationBox[\("exp = "\[InvisibleSpace]Integrate[
          x\^3 + 3\ x\^2\ y + 3\ x\ y\^2 + y\^3, x]\),
      SequenceForm[ "exp = ", 
        Integrate[ 
          Plus[ 
            Power[ x, 3], 
            Times[ 3, 
              Power[ x, 2], y], 
            Times[ 3, x, 
              Power[ y, 2]], 
            Power[ y, 3]], x]],
      Editable->False]], "Print"],

Cell[BoxData[
    \(x\^4\/4 + x\^3\ y + \(3\ x\^2\ y\^2\)\/2 + x\ y\^3\)], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Assistants in figuring things out", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
An assistant to understanding:  MapAt or ReplaceAll a Button to \
prominently display what targets are hit by your operation.\
\>", \
"Subsubsection"],

Cell[TextData[{
  "In the last section, toward the end I suggested a ",
  StyleBox["Hold", "Input",
    FontSize->12],
  "-like wrapper that would display itself as a frame, which is less \
obtrusive visually than ",
  StyleBox["Hold[...]", "Input",
    FontSize->12],
  " wrapped around everything in the expression.\n\nIn that vein, here is a \
technique that sometimes helps in debugging.  Use ",
  StyleBox["Map", "Input",
    FontSize->12],
  " or ",
  StyleBox["ReplaceAll", "Input",
    FontSize->12],
  " or other operations to wrap ",
  StyleBox["Button", "Input",
    FontSize->12],
  ", or some other prominently visible markup, around certain targets, \
especially if you're not sure what the targets will be."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[Button, \ 
      ToExpression["\<2 + 4 I - 5/7\>", \ InputForm, \ 
        HoldForm], \ {\(-1\)}]\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{
        ButtonBox["2"], "+", 
        RowBox[{
          ButtonBox["4"], " ", 
          ButtonBox["\[ImaginaryI]"]}], "+", 
        RowBox[{
          ButtonBox[\(-1\)], " ", 
          ButtonBox["5"], " ", 
          SuperscriptBox[
            ButtonBox["7"], 
            ButtonBox[\(-1\)]]}]}],
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[Button, \ 
      ToExpression["\<2 + 4 I - 5/7\>", \ InputForm, \ 
        HoldForm], \ {\(-1\)}, \ Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    RowBox[{
      ButtonBox["HoldForm"], "[", 
      RowBox[{
        ButtonBox["Plus"], "[", 
        RowBox[{
          ButtonBox["2"], ",", 
          RowBox[{
            ButtonBox["Times"], "[", 
            RowBox[{
              ButtonBox["4"], ",", 
              ButtonBox["\[ImaginaryI]"]}], "]"}], ",", 
          RowBox[{
            ButtonBox["Times"], "[", 
            RowBox[{
              ButtonBox[\(-1\)], ",", 
              ButtonBox["5"], ",", 
              RowBox[{
                ButtonBox["Power"], "[", 
                RowBox[{
                  ButtonBox["7"], ",", 
                  ButtonBox[\(-1\)]}], "]"}]}], "]"}]}], "]"}], 
      "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[\[IndentingNewLine]ToExpression["\<2 + 4 I - 5/7\>", \ 
        InputForm, \ 
        HoldForm], \[IndentingNewLine]num_\  /; \ 
          NumberQ\ @\ Unevaluated[num]\  \[RuleDelayed] \ 
        Button[num], \[IndentingNewLine]{\(-1\)}\[IndentingNewLine]]\)], \
"Input"],

Cell[BoxData[
    TagBox[
      RowBox[{
        ButtonBox["2"], "+", 
        RowBox[{
          ButtonBox["4"], " ", "\[ImaginaryI]"}], "+", 
        RowBox[{
          ButtonBox[\(-1\)], " ", 
          ButtonBox["5"], " ", 
          SuperscriptBox[
            ButtonBox["7"], 
            ButtonBox[\(-1\)]]}]}],
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(NumberQ\ @\ Unevaluated[I]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Another assistant:  ParsedForm to show how input parses, before it \
begins to evaluate\
\>", "Subsubsection"],

Cell[TextData[{
  "When I'm writing typesetting rules, or analyzing code, I often need to \
search for patterns in unevaluated input or code.  Sometimes the actual \
structure in the unevaluated form isn't what I deduce from its displayed form \
or my past playing with ",
  StyleBox["FullForm", "Input",
    FontSize->12],
  " of ",
  StyleBox["evaluated",
    FontSlant->"Italic"],
  " things.\n\nHere's a wrapper I've used for many years to show me how \
things parse, before they begin evaluating."
}], "Text"],

Cell[BoxData[{
    \(Attributes[ParsedForm]\  = \ HoldAll; \[IndentingNewLine]\), "\n", 
    \(Format[ParsedForm[expr_]]\  := \ HoldForm[FullForm[expr]]\)}], "Input"],

Cell["\<\
It reveals the parsed form of differences, fractions, and \"complex\
\" numbers.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ParsedForm[x\  - \ y]\)], "Input"],

Cell[BoxData[
    TagBox[
      TagBox[
        StyleBox[\(Plus[x, Times[\(-1\), y]]\),
          ShowSpecialCharacters->False,
          ShowStringCharacters->True,
          NumberMarks->True],
        FullForm],
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ParsedForm[1/5]\)], "Input"],

Cell[BoxData[
    TagBox[
      TagBox[
        StyleBox[\(Times[1, Power[5, \(-1\)]]\),
          ShowSpecialCharacters->False,
          ShowStringCharacters->True,
          NumberMarks->True],
        FullForm],
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ParsedForm[2\  - \ 5\ I]\)], "Input"],

Cell[BoxData[
    TagBox[
      TagBox[
        StyleBox[\(Plus[2, Times[\(-1\), Times[5, \\[ImaginaryI]]]]\),
          ShowSpecialCharacters->False,
          ShowStringCharacters->True,
          NumberMarks->True],
        FullForm],
      HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
  "This makes it obvious that these things aren't the same as you think if \
you call ",
  StyleBox["FullForm", "Input",
    FontSize->12],
  " on the ",
  StyleBox["evaluated",
    FontSlant->"Italic"],
  " forms a lot."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Using HoldForm to what it looked like before evaluation", \
"Subsubsection"],

Cell[TextData[{
  "A lot of people get confused by nested scoping constructs, in particular, \
the automatic renaming of the inner construct's local variables, e.g. ",
  StyleBox["x -> x$", "Input",
    FontSize->12],
  ".  Using ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  ", you capture on film what the outer construct did to the inner construct, \
before the inner construct even begins evaluating:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(With[{a\  = \ 3}, \ HoldForm\ @\ Module[{x}, \ x\  + \ a]]\)], "Input"],

Cell[BoxData[
    TagBox[\(Module[{x$}, x$ + 3]\),
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Module[{a\  = \ 0}, \ 
      HoldForm\ @\ Compile[{x, \ y}, \ a\ x\  + \ y]]\)], "Input"],

Cell[BoxData[
    TagBox[\(Compile[{x$, y$}, a$6234\ x$ + y$]\),
      HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(Function[{a}, \ HoldForm[f[x_, \ y_]\  = \ a\ x\  + \ y]]\)\ [
      7]\)], "Input"],

Cell[BoxData[
    TagBox[\(f[x$_, y$_] = 7\ x$ + y$\),
      HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
  "The same technique reveals that ",
  StyleBox["Block", "Input",
    FontSize->12],
  " doesn't participate in these lexical scoping activities.  If it is \
inside, its variables aren't renamed:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Module[{a\  = \ 0}, \ 
      HoldForm\ @\ Block[{x, \ y}, \ a\ x\  + \ y]]\)], "Input"],

Cell[BoxData[
    TagBox[\(Block[{x, y}, a$6233\ x + y]\),
      HoldForm]], "Output"]
}, Open  ]],

Cell["\<\
And if it is outside, it doesn't perform renaming on constructs \
inside:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{a\  = \ 0}, \ 
      HoldForm\ @\ Module[{x, \ y}, \ a\ x\  + \ y]]\)], "Input"],

Cell[BoxData[
    TagBox[\(Module[{x, y}, a\ x + y]\),
      HoldForm]], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["More on principles and methods", "Section"],

Cell[CellGroupData[{

Cell["\<\
Structural operations are your friends; they work well on \
unevaluated expressions.\
\>", "Subsection"],

Cell[CellGroupData[{

Cell["Flatten", "Subsubsection"],

Cell[TextData[{
  "An example of ",
  StyleBox["Flatten", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[BoxData[{
    \(ClearAll[f]\[IndentingNewLine]\), "\n", 
    \(Attributes[f]\  = \ HoldAll; \[IndentingNewLine]\), "\n", 
    \(f[Xor[
          elems___]]\  := \[IndentingNewLine]Replace[\[IndentingNewLine]Sort[
          Flatten[Hold[elems], \ Infinity, \ Xor]], \[IndentingNewLine]Hold[
            args___]\  \[RuleDelayed] \ 
          HoldForm[CirclePlus[args]]\[IndentingNewLine]]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[Xor[Xor[1\  \[Equal] \ 1, \ Xor[0\  \[Equal] \ 1]], \ 
        Xor[Xor[2\  \[Equal] \ 1, \ 1\  \[Equal] \ 0], \ 
          2\  \[Equal] \ 0]]]\)], "Input"],

Cell[BoxData[
    TagBox[\(\((0 == 1)\)\[CirclePlus]\((1 == 0)\)\[CirclePlus]\((1 == 
            1)\)\[CirclePlus]\((2 == 0)\)\[CirclePlus]\((2 == 1)\)\),
      HoldForm]], "Output"]
}, Open  ]],

Cell["\<\
Here is a function automatically flattens multiple levels of \
itself.  It also acts as the identity on a singleton.\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll[f]\[IndentingNewLine]\), "\n", 
    \(Attributes[f]\  = \ HoldAll; \[IndentingNewLine]\), "\n", 
    \(f[args___]\  /; \ MemberQ[Unevaluated[{args}], _f]\  := \ 
      Flatten[Unevaluated[f[args]], \ Infinity, \ 
        f]\[IndentingNewLine]\), "\n", 
    \(f[singleton_]\  := \ singleton\[IndentingNewLine]\), "\n", 
    \(f[elems___]\  := \ Hold[elems]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[f[1, \ 2], \ f[3, \ 4, \ 5], \ f[6, \ f[7, \ 8]]]\)], "Input"],

Cell[BoxData[
    \(Hold[1, 2, 3, 4, 5, 6, 7, 8]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1]\)], "Input"],

Cell[BoxData[
    \(1\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Usually people try to do this with ",
  StyleBox["Flat", "Input",
    FontSize->12],
  ", but that causes infinite recursion because ",
  StyleBox["Flat", "Input",
    FontSize->12],
  " also interferes with pattern-matching of your rules."
}], "Text"],

Cell[BoxData[{
    \(ClearAll[f]\[IndentingNewLine]\), "\n", 
    \(Attributes[f]\  = \ {HoldAll, \ Flat}; \[IndentingNewLine]\), "\n", 
    \(f[singleton_]\  := \ singleton\[IndentingNewLine]\), "\n", 
    \(f[elems___]\  := \ Hold[elems]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[f[1, \ 2], \ f[3, \ 4, \ 5], \ f[6, \ f[7, \ 8]]]\)], "Input"],

Cell[BoxData[
    \($IterationLimit::"itlim" \(\(:\)\(\ \)\) 
      "Iteration limit of \!\(4096\) exceeded."\)], "Message"],

Cell[BoxData[
    \(Hold[f[1, 2, 3, 4, 5, 6, 7, 8]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1]\)], "Input"],

Cell[BoxData[
    \($IterationLimit::"itlim" \(\(:\)\(\ \)\) 
      "Iteration limit of \!\(4096\) exceeded."\)], "Message"],

Cell[BoxData[
    \(Hold[f[1]]\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Thread", "Subsubsection"],

Cell["\<\
If your f is already a holding function, and you want to map it \
across a list, of course without letting the elements of the list evaluate \
before f gets to them, then you can do:\
\>", "Text"],

Cell[BoxData[
    \(List\  @@ \ \((f\  /@ \ Hold[e1, \ \[Ellipsis], \ en])\)\)], "Input"],

Cell[BoxData[
    \(ReleaseHold\ @\ 
      Map[f, \ Hold[{e1, \ \[Ellipsis], \ en}], \ {2}]\)], "Input"],

Cell[TextData[{
  "But an even more compact method is ",
  StyleBox["Thread", "Input",
    FontSize->12],
  ", which is really a controlled ",
  StyleBox["Listable", "Input",
    FontSize->12],
  ", just one application of ",
  StyleBox["Listable", "Input",
    FontSize->12],
  " instead of recursive application of it:"
}], "Text"],

Cell[BoxData[
    \(Thread\ @\ \(Unevaluated\ @\ f[{e1, \ \[Ellipsis], \ en}]\)\)], "Input"],

Cell[TextData[{
  "If you have to express it as a pure function, e.g. if f is a two-variable \
function, and one argument is some fixed value, then to make it holding, you \
must use ",
  StyleBox["Function[vars, body, attrs]", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[BoxData[
    \(List\  @@ \ \((Function[e, \ f[0, \ e], \ HoldFirst]\  /@ \ 
          Hold[e1, \ \[Ellipsis], \ en])\)\)], "Input"],

Cell[BoxData[
    \(ReleaseHold\ @\ 
      Map[Function[e, \ f[0, \ e], \ HoldFirst], \ 
        Hold[{e1, \ \[Ellipsis], \ en}], \ {2}]\)], "Input"],

Cell[TextData[{
  "However, again ",
  StyleBox["Thread", "Input",
    FontSize->12],
  " makes it short and elegant:"
}], "Text"],

Cell[BoxData[
    \(Thread[
      Unevaluated\ @\ f[0, \ {e1, \ \[Ellipsis], \ en}], \ \(-1\)]\)], "Input"],

Cell["Here's a real use from the top-level typesetting packages:", "Text"],

Cell["\<\
SetAttributes[{HeldOptionQ, HeldNonOptionQ}, HoldAllComplete]

HeldOptionQ[expr_] := OptionQ @ Unevaluated[expr]
HeldOptionQ[exprs__] := Thread[Unevaluated @ HeldOptionQ[And[exprs]], And]


HeldNonOptionQ[expr_] := Not @ HeldOptionQ[expr]
HeldNonOptionQ[exprs__] := Thread[Unevaluated @ HeldNonOptionQ[And[exprs]], \
And]\
\>", "Program",
  FontFamily->"Courier",
  FontSize->12],

Cell[TextData[{
  "Another real use in the typesetting packages is when I want to map ",
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  ", or its sister ",
  StyleBox["Parenthesize", "Input",
    FontSize->12],
  ", across a list:"
}], "Text"],

Cell[BoxData[
    \(Thread[\[IndentingNewLine]Unevaluated\ @\ 
        Parenthesize[{exprs}, fmt, 
          CompoundExpression], \[IndentingNewLine]List, \[IndentingNewLine]1\
\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  "To feed the output of ",
  StyleBox["MakeExpression", "Input",
    FontSize->12],
  " to something else without the ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  " wrapper.  Or in general, any function that returns result in ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " can feed its result, sans the wrapper, to another thing."
}], "Text"],

Cell[BoxData[
    \(TagBox /: 
      MakeExpression[TagBox[GridBox[boxexpr_, opts___], Grid], fmt_] := 
      Thread[Grid[MakeExpression[GridBox[boxexpr], fmt], opts], HoldComplete, 
        1]\)], "Input"],

Cell[TextData[{
  StyleBox["Grid", "Input",
    FontSize->12],
  " is conveniently inert; it just sits there and does nothing to its \
argument.  If your f doesn't sit still, use ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " or ",
  StyleBox["Block", "Input",
    FontSize->12],
  " methods:"
}], "Text"],

Cell[BoxData[
    \(\(ReleaseHold\ @\ 
          Thread[Unevaluated\ @\ f[#, opts], HoldComplete, 1] &\)\ @\ 
      MakeExpression[GridBox[boxexpr], fmt]\)], "Input"],

Cell[BoxData[
    \(Block[{f}, \[IndentingNewLine]ReleaseHold\ @\ 
        Thread[f[MakeExpression[GridBox[boxexpr], fmt], opts], HoldComplete, 
          1]\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  "In general, ",
  StyleBox["Thread", "Input",
    FontSize->12],
  " can be used to manually implement one level of ",
  StyleBox["Listable", "Input",
    FontSize->12],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Pointwise operators:  ReplacePart, Delete, FlattenAt, MapAt", \
"Subsubsection"],

Cell[TextData[{
  StyleBox["ReplacePart", "Input",
    FontSize->12],
  " gives you complete power to do whatever you want, though it takes a bit \
more work because you have to specify all the target locations.  With it, you \
can implement a ",
  StyleBox["ReplaceAt", "Input",
    FontSize->12],
  ", which gives you even finer control than ",
  StyleBox["Replace", "Input",
    FontSize->12],
  " with level specification."
}], "Text"],

Cell[TextData[{
  "Here's an ",
  StyleBox["EvaluateAt", "Input",
    FontSize->12],
  " function that evaluates just the subexpressions you tell it to.  I wrote \
this for the Further Examples during Version 3.0 development, and it's not \
the most efficient method, as its use of ",
  StyleBox["Fold", "Input",
    FontSize->12],
  " makes it O(n^2), but it illustrates what you can do:"
}], "Text"],

Cell[BoxData[
    \(EvaluateAt[expr_, positions_] := 
      Fold[ReplacePart[#1, Part[#1, Sequence @@ #2], #2] &, expr, 
        positions]\)], "Input"],

Cell[TextData[{
  "A faster implementation would be based on the 4-argument form of ",
  StyleBox["ReplacePart", "Input",
    FontSize->12],
  ".  I will include this in a later revision of this document."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Identify what's bad to evaluate:  the whole, or the parts, or the \
return value?\
\>", "Subsubsection"],

Cell[TextData[{
  "If the whole, then ",
  StyleBox["Block", "Input",
    FontSize->12],
  " is one of the easiest methods"
}], "Text"],

Cell[TextData[{
  "If the parts, then you're more likely to need ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " or ",
  StyleBox["Hold", "Input",
    FontSize->12],
  "* stuff.  You could use ",
  StyleBox["Block", "Input",
    FontSize->12],
  ", but then you have to assemble a list of all the types of parts and scope \
their heads."
}], "Text"],

Cell[TextData[{
  "If the return value must remain unevaluated, and you're going to return it \
to some arbitrary function calling you as a service, rather than you passing \
the unevaluated result immediately to some other function in your code, then \
you may have to return it wrapped in ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " or some holding container.  Like ",
  StyleBox["MakeExpression", "Input",
    FontSize->12],
  " (whose return value is in ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  ") or ",
  StyleBox["Trace", "Input",
    FontSize->12],
  " (whose return value wraps stages of evaluation in ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  ") or ",
  StyleBox["DownValues", "Input",
    FontSize->12],
  " (whose return value represents definitions, protecting the left-hand side \
with ",
  StyleBox["HoldPattern", "Input",
    FontSize->12],
  " and the right-hand side with ",
  StyleBox["RuleDelayed", "Input",
    FontSize->12],
  ")"
}], "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Some subtle topics to demystify", "Subsection"],

Cell[CellGroupData[{

Cell[TextData[{
  "Functions that hold some or all their arguments, e.g. Plot, Table, and \
HoldComplete, get ",
  StyleBox["all their power",
    FontSlant->"Italic"],
  " of preventing evaluation from ",
  StyleBox["attributes",
    FontSlant->"Italic"],
  "."
}], "Subsubsection"],

Cell[TextData[{
  "Some ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " users believe that functions such as ",
  StyleBox["Plot", "Input",
    FontSize->12],
  ", ",
  StyleBox["Table", "Input",
    FontSize->12],
  ", and ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  " have magical internal code to prevent their arguments from evaluating.  \
Well, there is no mysterious internal magic here.  These functions get all \
their power from the attributes they carry, e.g. ",
  StyleBox["HoldFirst", "Input",
    FontSize->12],
  ", ",
  StyleBox["HoldRest", "Input",
    FontSize->12],
  ", ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  ", ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  ".  You can endow your own functions with these attributes.\n\nIf a \
function is ",
  StyleBox["HoldFirst", "Input",
    FontSize->12],
  ", it will receive its first argument unevaluated, and the others \
evaluated.  It's that simple.  You the user can deprive any function of its \
power by using ",
  StyleBox["ClearAttributes", "Input",
    FontSize->12],
  ".  Example:  ",
  StyleBox["Context", "Input",
    FontSize->12],
  " must receive its first argument unevaluated, since it might be a symbol \
with a value."
}], "Text"],

Cell[BoxData[
    \(x\  = \ 777; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Context[x]\)], "Input"],

Cell[BoxData[
    \("Global`"\)], "Output"]
}, Open  ]],

Cell[BoxData[
    \(ClearAttributes[Context, \ HoldFirst]; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Context[x]\)], "Input"],

Cell[BoxData[
    \(Context::"ssle" \(\(:\)\(\ \)\) 
      "Symbol, string, or HoldPattern[symbol] expected at position \!\(1\) in \
\!\(Context[777]\)."\)], "Message"],

Cell[BoxData[
    \(Context[777]\)], "Output"]
}, Open  ]],

Cell[BoxData[
    \(SetAttributes[Context, \ HoldFirst]; \)], "Input"],

Cell[TextData[{
  "It's actually the ",
  StyleBox["top-level evaluator that decides",
    FontSlant->"Italic"],
  " what arguments a function receives, not the function itself.  The \
evaluator always looks at a function call's arguments and does \
pre-processing, unless the function carries the attribute ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  ".  Even the ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " attribute allows a few kinds of pre-processing to take effect:  ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " take effect, ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " is flattened, and ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " of the arguments do fire."
}], "Text"],

Cell[TextData[{
  StyleBox["Hold", "Input",
    FontSize->12],
  " is the prototypical ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " function:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Attributes[Hold]\)], "Input"],

Cell[BoxData[
    \({HoldAll, Protected}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "It lets ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " and ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " do their thing:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Hold[Evaluate[1\  + \ 2], \ Sequence[7, \ Print[8]]]\)], "Input"],

Cell[BoxData[
    \(Hold[3, 7, Print[8]]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  " is stronger; it doesn't allow even this:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(HoldComplete[Evaluate[1\  + \ 2], \ Sequence[7, \ Print[8]]]\)], "Input"],

Cell[BoxData[
    \(HoldComplete[Evaluate[1 + 2], Sequence[7, Print[8]]]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "But deprive of its ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " attribute, and it becomes powerless to hold anything.  However, you'd \
better not do this when running in the front end, because ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  " is used by the typesetting code,which is an integral part of the main \
loop when you're in a front end."
}], "Text"],

Cell[TextData[{
  "For more information, see \"A.4.1 The Standard Evaluation Sequence\" in \
The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book, or for even more detail, Dave Withoff's talk from the 1992 \
conference Course Notes."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Misconception:  Block will deactivate absolutely all properties and \
meaningful behavior of a symbol in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  ".  Wrong!  Only ",
  StyleBox["rewrite rules",
    FontSlant->"Italic"],
  " are deactivated."
}], "Subsubsection"],

Cell[TextData[{
  "Basically, a command or function that ",
  StyleBox["performs an action",
    FontSlant->"Italic"],
  " or ",
  StyleBox["applies a transformation",
    FontSlant->"Italic"],
  ", e.g. ",
  StyleBox["OpenWrite", "Input",
    FontSize->12],
  ", ",
  StyleBox["Map", "Input",
    FontSize->12],
  ", and so on, you can deactivate.  ",
  StyleBox["Block", "Input",
    FontSize->12],
  " will turn off just about all the these properties of a symbol (both \
top-level and built-in versions of these):"
}], "Text"],

Cell[BoxData[
    \($ValueTypes = {Attributes, DefaultValues, DownValues, FormatValues, 
        NValues, OwnValues, Options, SubValues, UpValues}\)], "Input"],

Cell[TextData[{
  "which are the assignments to a symbol.  This is about what you expect, and \
won't surprise you, though note ",
  StyleBox["FormatValues", "Input",
    FontSize->12],
  ", which means that ",
  StyleBox["Block", "Input",
    FontSize->12],
  " will also turn off pretty-printing rules for the symbol, a fact that is \
often missed, and is sometimes useful, sometimes annoying."
}], "Text"],

Cell[TextData[{
  "But some symbols have a special meaning that is recognized by some other \
part of the system, such as the fact that ",
  StyleBox["Slot", "Input",
    FontSize->12],
  " is recognized by ",
  StyleBox["Function", "Input",
    FontSize->12],
  " as labelling the function's formal variables.  It may surprise you that \
such extrinsic properties are ",
  StyleBox["not deactivated",
    FontSlant->"Italic"],
  " by ",
  StyleBox["Block", "Input",
    FontSize->12],
  "!"
}], "Text"],

Cell[TextData[{
  "Here are a few  categories of properties that ",
  StyleBox["Block", "Input",
    FontSize->12],
  " will ",
  StyleBox["not",
    FontSlant->"Italic"],
  " deactivate, to give you a feeling for the limits of ",
  StyleBox["Block", "Input",
    FontSize->12],
  ":\n\n(1)  Attributes, e.g. ",
  StyleBox["Listable", "Input",
    FontSize->12],
  " and ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  ".\n\n(2)  Names of options, e.g. ",
  StyleBox["PlotPoints", "Input",
    FontSize->12],
  " or ",
  StyleBox["WorkingPrecision", "Input",
    FontSize->12],
  ".\n\n(3)  The meta-expression status of the various pattern types:  ",
  StyleBox["Pattern", "Input",
    FontSize->12],
  ", ",
  StyleBox["Blank", "Input",
    FontSize->12],
  "*, ",
  StyleBox["Repeated", "Input",
    FontSize->12],
  "*, ",
  StyleBox["Alternatives", "Input",
    FontSize->12],
  ", ",
  StyleBox["Optional", "Input",
    FontSize->12],
  ", ",
  StyleBox["PatternTest", "Input",
    FontSize->12],
  ", ",
  StyleBox["Condition", "Input",
    FontSize->12],
  ", ",
  StyleBox["HoldPattern (", "Input",
    FontSize->12],
  "formerly ",
  StyleBox["Literal)", "Input",
    FontSize->12],
  ", ",
  StyleBox["Verbatim", "Input",
    FontSize->12],
  ".\n\n(4)  The fact that ",
  StyleBox["Slot[i]", "Input",
    FontSize->12],
  " and ",
  StyleBox["SlotSequence[i]", "Input",
    FontSize->12],
  ", i.e. ",
  StyleBox["#n", "Input",
    FontSize->12],
  " and ",
  StyleBox["##n", "Input",
    FontSize->12],
  ",  refer to the arguments of ",
  StyleBox["Function[body]", "Input",
    FontSize->12],
  ".\n\n(5)  The status of being a lexical scoping construct, including ",
  StyleBox["Module", "Input",
    FontSize->12],
  ", ",
  StyleBox["With", "Input",
    FontSize->12],
  ", ",
  StyleBox["Function", "Input",
    FontSize->12],
  ", ",
  StyleBox["Compile", "Input",
    FontSize->12],
  ", the ",
  StyleBox["Rule", "Input",
    FontSize->12],
  "* and *",
  StyleBox["Set", "Input",
    FontSize->12],
  "* family, ",
  StyleBox["Condition", "Input",
    FontSize->12],
  ", when it comes to things like variable renaming ",
  StyleBox["x -> x$", "Input",
    FontSize->12],
  ".  Though ",
  StyleBox["Block", "Input",
    FontSize->12],
  " can certainly make any of these a do-nothing command.\n\n(6)  Lots of \
other magic symbols like ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  ", ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  ", ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  "; and just about any symbol that is simply a name or container for data \
that is recognized or acted upon by an actual command or function: ",
  StyleBox["Rule", "Input",
    FontSize->12],
  " and ",
  StyleBox["RuleDelayed", "Input",
    FontSize->12],
  "; ",
  StyleBox["LinkObject", "Input",
    FontSize->12],
  ", ",
  StyleBox["InputStream", "Input",
    FontSize->12],
  ", and ",
  StyleBox["OutputStream", "Input",
    FontSize->12],
  "; ",
  StyleBox["Word", "Input",
    FontSize->12],
  " and ",
  StyleBox["Number;", "Input",
    FontSize->12],
  " ",
  StyleBox["MessageName", "Input",
    FontSize->12],
  ", ",
  StyleBox["Label", "Input",
    FontSize->12],
  " (for ",
  StyleBox["Goto", "Input",
    FontSize->12],
  "); many others."
}], "Text"],

Cell["Further explanation and examples:", "Text",
  FontWeight->"Bold"],

Cell["\<\
(1)  Attributes

They do not derive their power from having rewrite rules attached to them; \
i.e. they don't have \"function definitions\".  Their power is that major \
subsystems of the kernel, such as the evaluator, the pattern-matcher, and \
lexical scoping, recognize them conferring special properties to \
symbols.\
\>", "Text"],

Cell[TextData[{
  StyleBox["Block", "Input",
    FontSize->12],
  "'ing ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " doesn't affect ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " functions:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{HoldAll, \ 
        f}, \[IndentingNewLine]Attributes[
          f]\  = \ {HoldAll}; \[IndentingNewLine]f[expr_]\  = \ 
        0; \[IndentingNewLine]f[Print[3]]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "If ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " lost its meaning, then f would have let ",
  StyleBox["Print[3]", "Input",
    FontSize->12],
  " evaluate, as below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Attributes, \ 
        f}, \[IndentingNewLine]Attributes[
          f]\  = \ {HoldAll}; \[IndentingNewLine]f[expr_]\  = \ 
        0; \[IndentingNewLine]f[Print[3]]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(3\)], "Print"],

Cell[BoxData[
    \(0\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "(2)  Option names, and symbolic option values, are recognized by the \
parent function, they don't have their own values.  You must ",
  StyleBox["Block", "Input",
    FontSize->12],
  " the parent function if you want to deactivate it."
}], "Text"],

Cell["\<\
(3)  Patterns are just data types recognized as special by one \
major subsystem of the kernel:  the pattern-matcher.  They don't have values.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Pattern, Blank}, \[IndentingNewLine]Replace[0, \ 
        i_Integer\  \[RuleDelayed] \ 
          Hold[i^2]]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(Hold[0\^2]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "(4)  ",
  StyleBox["Slot", "Input",
    FontSize->12],
  " variables of ",
  StyleBox["Function", "Input",
    FontSize->12],
  " are again data types given special meaning by their parent function.  \
Neither of these fails, nor should it:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Slot}, \[IndentingNewLine]\(\((#\  + \ 1)\) &\)\ [
        0]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(1\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{x}, \[IndentingNewLine]\(Function[x, \ x\  + \ 1]\)\ [
        0]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(1\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "But this will make ",
  StyleBox["Function", "Input",
    FontSize->12],
  " a no-op:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Function}, \[IndentingNewLine]Print[\ {\(\((#\  + \ 1)\) &\)\ [
            0], \ \(Function[x, \ x\  + \ 1]\)\ [
            0]}\ ]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \({\((1 + #1 &)\)[0], \(Function[x, 1 + x]\)[0]}\)], "Print"]
}, Open  ]],

Cell[TextData[{
  "(5)  ",
  StyleBox["Module", "Input",
    FontSize->12],
  " and the rest of the lexical scoping family \"respect\" each other by not \
overwriting each other's local variables (well, ",
  StyleBox["Rule", "Input",
    FontSize->12],
  " and ",
  StyleBox["Set", "Input",
    FontSize->12],
  " do), and by renaming each other's variables if there is potential \
intersection of scope.  You can make ",
  StyleBox["Function", "Input",
    FontSize->12],
  " a no-op, but it will still be respected as a scoping construct by a ",
  StyleBox["With", "Input",
    FontSize->12],
  " that contains it, and thus can have its variables renamed."
}], "Text"],

Cell["Here's the renaming captured:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(With[{a\  = \ 1}, \ 
      HoldForm[\ \(Function[x, \ x\  + \ a]\)[2]\ ]\ ]\)], "Input"],

Cell[BoxData[
    TagBox[\(\(Function[x$, x$ + 1]\)[2]\),
      HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Here we prove that ",
  StyleBox["Function", "Input",
    FontSize->12],
  " is a no-op, but renaming still happens."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Function}, \[IndentingNewLine]\[IndentingNewLine]With[{a\  = \ 
            1}, \ Print[\ \(Function[x, \ x\  + \ a]\)[
            2]\ ]\ ]\[IndentingNewLine]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(\(Function[x$, 1 + x$]\)[2]\)], "Print"]
}, Open  ]],

Cell[TextData[{
  "(6)  Miscelleaneous meaningful names without values.\n\nBe careful what \
you deactivate.  If you make ",
  StyleBox["Module", "Input",
    FontSize->12],
  " or ",
  StyleBox["LinkWrite", "Input",
    FontSize->12],
  " or certain other things into no-ops, you might cripple the system."
}], "Text"],

Cell["\<\
You must deactivate the symbol which owns the definitions or \
rules\
\>", "Text",
  FontSize->16,
  FontWeight->"Bold"],

Cell[TextData[{
  "Sometimes you may guess wrong as to which symbol owns the definitons you \
want to deactivate.  For instance, if you want to disable typeset output in a \
procedure, ",
  StyleBox["Block", "Input",
    FontSize->12],
  "'ing ",
  StyleBox["StandardForm", "Input",
    FontSize->12],
  " will disable few, if any, output forms."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{StandardForm}, \ Print[x^2\  - \ y/3]]\)], "Input"],

Cell[BoxData[
    \(x\^2 - y\/3\)], "Print"]
}, Open  ]],

Cell["But this works as you wish:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Plus, \ Power, \ Times}, \ Print[x^2\  - \ y/3]]\)], "Input"],

Cell[BoxData[
    \(x^2 + \(-1\)*\((y*3^\((\(-1\))\))\)\)], "Print"]
}, Open  ]],

Cell[TextData[{
  "Most formatting rules are associated with individual functions, not with \
types like ",
  StyleBox["OutputForm", "Input",
    FontSize->12],
  " or ",
  StyleBox["StandardForm", "Input",
    FontSize->12],
  ".  There are exceptions; ",
  StyleBox["TraditionalForm", "Input",
    FontSize->12],
  " carries some formatting rules (and has an auto-loading rule attached to \
it)."
}], "Text"],

Cell[TextData[{
  "Another case:  ",
  StyleBox["MessageName", "Input",
    FontSize->12],
  " has only a formatting rule; it's not in charge of issuing messages:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{MessageName}, \ 1/0]\)], "Input"],

Cell[BoxData[
    \(MessageName[Power, "infy"] \(\(:\)\(\ \)\) 
      "Infinite expression \!\(1\/0\) encountered."\)], "Message"],

Cell[BoxData[
    InterpretationBox["ComplexInfinity",
      DirectedInfinity[ ]]], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["Message", "Input",
    FontSize->12],
  " is in charge of this:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Message}, \ 1/0]\)], "Input"],

Cell[BoxData[
    InterpretationBox["ComplexInfinity",
      DirectedInfinity[ ]]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Why is MakeBoxes so nasty, I mean HoldAllComplete?", "Subsubsection"],

Cell[TextData[{
  "It's not simply a user function for typesetting.  It's a core part of the \
main loop when the kernel is being run in a front end.  And any expression, \
including ",
  StyleBox["Sequence[1, 2]", "Input",
    FontSize->12],
  " or ",
  StyleBox["Unevaluated[3 + 4]", "Input",
    FontSize->12],
  ", could be the result of an evaluation, assigned to ",
  StyleBox["Out[n]", "Input",
    FontSize->12],
  ".  Even a ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " function would flatten ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " or discard ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ".\n\nFurthermore, a user could have a universal ",
  StyleBox["UpValue", "Input",
    FontSize->12],
  " such as\n\n",
  StyleBox["  f /: _[fExpr_f, ___] := fExpr", "Input",
    FontSize->12],
  StyleBox["\n\n",
    FontSize->12],
  "She might do this to define some data type that should be \"slippery\", \
and not allow things to act on it, or to make the data type also canonicalize \
itself or alter itself depending on the caller.  In fact, ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " itself could almost be implemented as a universal ",
  StyleBox["UpValue", "Input",
    FontSize->12],
  " (maybe Dave Withoff or Roman Maeder remembers if that's not quite true).\n\
 \nBut it would be a disaster if one of the main components of the main loop \
allowed itself to be rewritten or discarded, such as the output formatter, \
because then this part of the main loop could not complete.\n\nSo that's why \
we needed a few functions able to prevent ",
  StyleBox["any rewrites whatsoever",
    FontSlant->"Italic"],
  " from occurring."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["When to use the different categories of holding stuff?", "Subsubsection"],

Cell[TextData[{
  "Here are some categories of holding methods we've discussed:\n\n(1) ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  "\n\n(2) the ",
  StyleBox["Hold", "Input",
    FontSize->12],
  "* family and ",
  StyleBox["ReleaseHold", "Input",
    FontSize->12],
  "\n\n(3) give my function f some ",
  StyleBox["Hold", "Input",
    FontSize->12],
  "* attribute\n\n(D) ",
  StyleBox["HoldPattern", "Input",
    FontSize->12],
  " is ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " for patterns, but it can occur at any depth, and no matter where it \
occurs, it is transparent to the pattern matcher.  For purposes of \
pattern-matching, it's as if the HoldPattern wrapper isn't there, yet its \
effect is felt because it prevented evaluation at storage-time of the rule."
}], "Text"],

Cell["\<\


This section isn't very polished, but here are some of my thoughts on when to \
use each.\
\>", "Text"],

Cell[TextData[{
  "(1)  Use ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " for one-shot passing of unevaluated argument."
}], "Text"],

Cell[TextData[{
  "(2)  Use ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " containers if you need to play with an expression for a while, can't just \
have it sit still for one operation.  Or if you need to ",
  StyleBox["return a value",
    FontSlant->"Italic"],
  " ",
  "unevaluated",
  ".  Anything you return from a function will instantly get fully evaluated, \
so you have to use a protective container."
}], "Text"],

Cell[TextData[{
  "(3)  When your function most of the time needs to operate on held thing.\n\
\n- anything that acts on a symbol itself as a name.  ",
  StyleBox["Context", "Input",
    FontSize->12],
  ", ",
  StyleBox["AppendTo", "Input",
    FontSize->12],
  ", ",
  StyleBox["SetDelayed", "Input",
    FontSize->12],
  ".\n\n- If you're making a programming construct that must establish a \
special environment before executing the body, e.g. scoping of vars, setting \
state vars, turning on logging or tracing, trapping calls to built-ins, etc.  \
Iterators like ",
  StyleBox["Table", "Input",
    FontSize->12],
  " and ",
  StyleBox["Plot", "Input",
    FontSize->12],
  " need to pre-scope the variable.\n\n- When your function is a formatter, \
whose job is simply to print the structure as is for display, speech \
rendering, or whatever.  \.14This applies to tex, typeset, or other output \
forms.\n\n   Another way to think of this is that output formatting is a \
different subsystem from evaluation, so it doesn't recognize the evaluator's \
special flags such as Evaluate and Sequence as anything special."
}], "Text"],

Cell["\<\
Hold vs. HoldComplete (or attribute HoldAll vs. \
HoldAllComplete)\
\>", "Text",
  FontWeight->"Bold"],

Cell[TextData[{
  "When is ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " a strong enough attribute for your function, and when is ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " necessary?\n\nUnless your function must treat ",
  StyleBox["Sequence[...]", "Input",
    FontSize->12],
  " and ",
  StyleBox["Evaluate[...]", "Input",
    FontSize->12],
  " as generic expressions with no meaning, or it needs to prevent ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " of its arguments from firing, then you don't need ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[TextData[{
  "Ask yourself:  ",
  StyleBox["Why is it compelling",
    FontSlant->"Italic"],
  " for me to override the normal semantics of ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " and ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " and ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  ", to prevent ",
  StyleBox["f[Evaluate[1 + 2]]", "Input",
    FontSize->12],
  " from calling ",
  StyleBox["f[3]", "Input",
    FontSize->12],
  "?\nIt had better be that f almost always wants to consider ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " a dumb expression, not something meaningful."
}], "Text"],

Cell[TextData[{
  "Not many functions carry the attribute ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[Names["\<System`*\>"], \ 
      MemberQ[Attributes\  @@ \ ToHeldExpression[#], \ 
          HoldAllComplete] &]\)], "Input"],

Cell[BoxData[
    \({"HoldComplete", "InterpretationBox", "MakeBoxes", "Parenthesize", 
      "Unevaluated"}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  ", and its sibling ",
  StyleBox["Parenthesize", "Input",
    FontSize->12],
  ", must be able to format absolutely any expression for output, as it is a \
critical part of the main loop when a front end is involved.  If the result \
of evaluation is ",
  StyleBox["Sequence[1, 2]", "Input",
    FontSize->12],
  ", or if you display ",
  StyleBox["DownValues[f]", "Input",
    FontSize->12],
  " and a piece of code contains ",
  StyleBox["Evaluate[arg]", "Input",
    FontSize->12],
  ", ",
  StyleBox["MakeBoxes", "Input",
    FontSize->12],
  " ",
  StyleBox["must",
    FontSlant->"Italic"],
  " treat it as a dumb expression."
}], "Text"],

Cell[TextData[{
  StyleBox["Cardinal rule",
    FontWeight->"Bold",
    FontSlant->"Italic"],
  ":  Formatting must never evaluate what it is given.  It should simply \
figure out how to display it, never evaluating any parts."
}], "Text"],

Cell[TextData[{
  "Not many functions are ",
  StyleBox["SequenceHold", "Input",
    FontSize->12],
  ", either:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[Names["\<System`*\>"], \ 
      MemberQ[Attributes\  @@ \ ToHeldExpression[#], \ 
          SequenceHold] &]\)], "Input"],

Cell[BoxData[
    \({"Rule", "RuleDelayed", "Set", "SetDelayed", "TagSet", "TagSetDelayed", 
      "Timing", "UpSet", "UpSetDelayed"}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Other than the ",
  StyleBox["Rule", "Input",
    FontSize->12],
  "* and *",
  StyleBox["Set", "Input",
    FontSize->12],
  "* family, which need to handle an rhs (right-hand side) of ",
  StyleBox["Sequence[...]", "Input",
    FontSize->12],
  ", there is only one function that prevents flattening of sequences:  ",
  StyleBox["Timing", "Input",
    FontSize->12],
  ".  I don't offhand know why it is more compelling for ",
  StyleBox["Timing", "Input",
    FontSize->12],
  " to handle ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " input than, say, the ",
  StyleBox["Trace", "Input",
    FontSize->12],
  "* family, so let's ask someone else this question.  In other words, why is \
it more unreasonable to require the user to do ",
  StyleBox["Timing[Unevaluated[Sequence[...]]]", "Input",
    FontSize->12],
  " than to require ",
  StyleBox["Timing[Unevaluated[Sequence[...]]]", "Input",
    FontSize->12],
  "?"
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Myth debunking:  HoldAllComplete isn't some super insulator against \
the parser, against generic structural operations or pattern-finders or the \
like.  It is somewhat more powerful than HoldAll, in four ways, and that's \
it!\
\>", "Subsubsection"],

Cell[TextData[{
  "A function h with the attribute ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  ", such as ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  ", is only slightly stronger than one with the ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " attribute, despite its reputation as some super insulator that prevents \
anything from happening inside it.  The differences are for arguments at \
level 1 of h[...]:\n\n(1)  ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " won't be flattened\n\n(2)  ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " won't cause evaluation.\n\n(3)  ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " won't be discarded before the argument is fed to a definition.\n\n(4)  \
g[...] won't cause an ",
  StyleBox["UpValue", "Input",
    FontSize->12],
  " for g to fire even if the rule matches."
}], "Text"],

Cell[TextData[{
  StyleBox["\[HappySmiley]",
    FontSize->24,
    FontColor->RGBColor[1, 0, 1]],
  "  Hence, you can modify or analyze held expressions with all the familiar \
functional and other commands, e.g. ",
  StyleBox["Map, ReplaceAll, FlattenAt, DeleteCases, Count", "Input",
    FontSize->12],
  ", whatever you want."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Argument evaluation precedes {Listable, Orderless, Flat, ...}, and \
any other structure-rewriting attributes.\
\>", "Subsubsection"],

Cell[TextData[{
  "Thus, if you make nested ",
  StyleBox["Dot", "Input",
    FontSize->12],
  " calls on actual matrices, the grouping you specified will be respected, \
even though ",
  StyleBox["Dot", "Input",
    FontSize->12],
  " carries the attribute ",
  StyleBox["Flat", "Input",
    FontSize->12],
  ".  You might think it would not because if you evaluate it for abstract \
symbolic arguments, it is treated as if it's associative:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Dot[Dot[A, \ Dot[B, \ C]], \ Dot[D, \ B]]\)], "Input"],

Cell[BoxData[
    \(A . B . C . D . B\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "But if the symbols are actual matrices, then the innermost ",
  StyleBox["Dot", "Input",
    FontSize->12],
  "'s will evaluate fully before the outer ",
  StyleBox["Dot", "Input",
    FontSize->12],
  " acts, so it will work fine."
}], "Text"],

Cell[TextData[{
  "In some cases, you want a function to invoke attributes on the original \
form of the arguments, not on the post-evaluated arguments.  You do that \
simply by adding ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " to the attributes:"
}], "Text"],

Cell[BoxData[
    \(Attributes[f]\  = \ {Flat}; \)], "Input"],

Cell[BoxData[
    \(SetAttributes[f, \ HoldAll]; \)], "Input"],

Cell[BoxData[
    \(f[whatever]\  := \ whatever\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Wrapping an argument in Unevaluated does NOT prevent that \
argument's head from exercising its UpValues!\
\>", "Subsubsection"],

Cell[BoxData[{
    \(ClearAll["\<a\>"]; \), "\n", 
    \(a\  /: \ _[___, \ a, \ ___]\  := \ \((Print["\<a fired\>"]; \ 
        Null)\)\)}], "Input"],

Cell[BoxData[
    \(f[x_]\  := \ HoldComplete[x]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[a]\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[Unevaluated[a]]\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"]
}, Open  ]],

Cell[TextData[{
  "The reason is that ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " simply ensures that the symbol 'a' is passed to f in original form, then \
",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " disappears.  "
}], "Text"],

Cell["\<\
So how do you assign new values to it?  Set and Unset and family \
don't work:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(a\  =. \)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(a\  = \ 0; \)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?\ a\)\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"],

Cell[BoxData[
    \("Global`a"\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(_[___, a, ___] ^:= \((Print["a fired"]; )\)\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ a],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(TagUnset[
      Unevaluated[a], \[IndentingNewLine]HoldPattern[
        HoldPattern[\[IndentingNewLine]_[___, \ 
            a, \ ___]\[IndentingNewLine]]]]\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? \ a\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"],

Cell[BoxData[
    \("Global`a"\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(_[___, a, ___] ^:= \((Print["a fired"]; )\)\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ a],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(HoldPattern\ @\ HoldPattern[a]\  = \ 0\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?\ a\)\)], "Input"],

Cell[BoxData[
    \("a fired"\)], "Print"],

Cell[BoxData[
    \("Global`a"\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(HoldPattern[HoldPattern[a]] = 0\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]},
          {" "},
          {GridBox[{
                {\(_[___, a, ___] ^:= \((Print["a fired"]; )\)\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ a],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Print\ @\ \(Unevaluated\ @\ Definition[a]\)\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(_[___, a, ___] ^:= \((Print["a fired"]; )\)\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ a],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Print\ @\ \(Unevaluated\ @\ FullDefinition[a]\)\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {GridBox[{
                      {\(_[___, a, ___] ^:= \((Print["a fired"]; )\)\)}
                      },
                    GridBaseline->{Baseline, {1, 1}},
                    ColumnWidths->0.999,
                    ColumnAlignments->{Left}]}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      FullDefinition[ a],
      Editable->False]], "Print"]
}, Open  ]],

Cell["This is a puzzle for the reader.", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
\"Non-standard Evaluation\":  That unexplained complicated thing.\
\
\>", "Subsubsection"],

Cell["Listing of types of special evaluation", "Text",
  FontSize->16,
  FontWeight->"Bold"],

Cell["There are different categories of  non-standard evaluation.", "Text"],

Cell[TextData[{
  "(1)  ",
  StyleBox["Left-hand side of ",
    FontVariations->{"Underline"->True}],
  StyleBox["assignments",
    FontSlant->"Italic",
    FontVariations->{"Underline"->True}],
  " (NOT ",
  StyleBox["rules",
    FontSlant->"Italic"],
  "!) \[Element] {*",
  StyleBox["Set", "Input",
    FontSize->12],
  "* and *",
  StyleBox["SetDelayed", "Input",
    FontSize->12],
  "* family, ",
  StyleBox["AddTo", "Input",
    FontSize->12],
  " & ",
  StyleBox["SubtractFrom", "Input",
    FontSize->12],
  " & ",
  StyleBox["TimesBy", "Input",
    FontSize->12],
  " & ",
  StyleBox["DivideBy", "Input",
    FontSize->12],
  ", ",
  StyleBox["AppendTo", "Input",
    FontSize->12],
  ", ",
  StyleBox["PrependTo", "Input",
    FontSize->12],
  "}.  Hopefully this is a complete listing of destructive functions in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  ".\n",
  StyleBox["How they are special",
    FontVariations->{"Underline"->True}],
  ":  They evaluate head and args, but don't let head ",
  StyleBox["act on",
    FontSlant->"Italic"],
  " args.  Of course, if head is a holding container, then args won't even \
evaluate, so this is consistent with evaluating ordinary expressions.  You \
could just about simulate what the partially evaluated lhs will be in the \
stored assignment:"
}], "Text"],

Cell[BoxData[
    \(H[e1, \ \[Ellipsis], \ en]\  := \ rhs\)], "Input"],

Cell["\<\
by evaluating the head and args separately, then sticking them into \
a template\
\>", "Text"],

Cell[BoxData[
    \(\(HoldComplete[\ #1[##2]\ ] &\)\ [H, \ e1, \ \[Ellipsis], \ 
      en]\)], "Input"],

Cell[TextData[{
  "(2)  ",
  StyleBox["Iterators",
    FontVariations->{"Underline"->True}],
  " \[Element] {",
  StyleBox["Table", "Input",
    FontSize->12],
  " & ",
  StyleBox["Do", "Input",
    FontSize->12],
  " & ",
  StyleBox["While", "Input",
    FontSize->12],
  " & ",
  StyleBox["For", "Input",
    FontSize->12],
  ", ",
  StyleBox["Sum", "Input",
    FontSize->12],
  " & ",
  StyleBox["Product", "Input",
    FontSize->12],
  ", ",
  StyleBox["Plot", "Input",
    FontSize->12],
  " and ",
  StyleBox["Play", "Input",
    FontSize->12],
  " family},\nbut NOT functional iterators or recursors {",
  StyleBox["Nest", "Input",
    FontSize->12],
  " and ",
  StyleBox["Fold", "Input",
    FontSize->12],
  " family, ",
  StyleBox["Array", "Input",
    FontSize->12],
  ", ",
  StyleBox["Map", "Input",
    FontSize->12],
  " and its many related things)\n",
  StyleBox["How they are special",
    FontVariations->{"Underline"->True}],
  ":  They dynamically scope the iterator variables (found in rgs 2 and \
beyond) then evaluate the iterand (arg 1) for all values of the iterators in \
sequence."
}], "Text"],

Cell[TextData[{
  "(3)  ",
  StyleBox["Misc. control structures",
    FontVariations->{"Underline"->True}],
  ":  {",
  StyleBox["And, Or, If, Which, Switch", "Input",
    FontSize->12],
  ")\n",
  StyleBox["How they are special",
    FontVariations->{"Underline"->True}],
  ":  They basically go from left to right, but don't necessarily evaluate \
all arguments.  In fact, except for the short-circuit ",
  StyleBox["And", "Input",
    FontSize->12],
  " and ",
  StyleBox["Or", "Input",
    FontSize->12],
  ", they are guaranteed not to evaluate all args if there are two or more \
branches (a single branch would be a degenerate case for ",
  StyleBox["If", "Input",
    FontSize->12],
  ", ",
  StyleBox["Which", "Input",
    FontSize->12],
  ", and ",
  StyleBox["Switch", "Input",
    FontSize->12],
  ")."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Switch[0, \[IndentingNewLine]_String, \ 
      Print["\<String\>"], \[IndentingNewLine]_Symbol, \ 
      Print["\<Symbol\>"], \[IndentingNewLine]_Integer, \ 
      Print["\<Integer\>"]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \("Integer"\)], "Print"]
}, Open  ]],

Cell[TextData[{
  "(4)  ",
  StyleBox["Scoping constructs",
    FontVariations->{"Underline"->True}],
  ":  ",
  StyleBox["Module, With, Block, Function, Compile, Condition", "Input",
    FontSize->12],
  " (of course, the *",
  StyleBox["Rule", "Input",
    FontSize->12],
  "* and *",
  StyleBox["Set", "Input",
    FontSize->12],
  "* family are scoping constructs, too, but when categorizing things \
according to uneval'n behavior, they don't belong in this category).\n",
  StyleBox["How they are special",
    FontVariations->{"Underline"->True}],
  ":  \n\n",
  StyleBox["Short Version",
    FontVariations->{"Underline"->True}],
  ":\n- Evaluate initializations of localvars\n- Perform actual scoping of \
declared local vars by either temporarily forgetting their own values \
(dynamic scoping) or by marking their occurrences in unevaluated body.\n- \
Evaluate body (either with its fixed set of markings, known as static \
scoping; or with no markings cuz original symbols are being used simply with \
new values, known as dynamic scoping)"
}], "Text"],

Cell[TextData[{
  "(5)  Miscellaneous:\n\nMany others query or modify their argument, like ",
  StyleBox["Context", "Input",
    FontSize->12],
  " and ",
  StyleBox["Protect", "Input",
    FontSize->12],
  ", which act on symbols.  Nothing special; they just need to receive the \
symbol intact in case it has a value.\n\nSome things set up a special \
environment, such as the ",
  StyleBox["Trace", "Input",
    FontSize->12],
  "* and ",
  StyleBox["Stack", "Input",
    FontSize->12],
  "* family, which turn on extra logging info."
}], "Text"],

Cell["\<\



\
\>", "Text"],

Cell[TextData[{
  StyleBox["Long Version",
    FontVariations->{"Underline"->True}],
  ":\nFirst they look at the local variable declaration.  If there are any \
initializations, they evaluate those, in the outside scope.\nThen they \
\"perform localization\" of the declared local vars.\nFinally they evaluate \
the body with this localization \"in effect\"."
}], "Text"],

Cell[BoxData[
    \(ScopingConstruct[{v1\  = \ a1, \ \[Ellipsis], \ 
        vn\  = \ an}, \[IndentingNewLine]body\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  "\"perform localization\":\n\n- ",
  StyleBox["Block", "Input",
    FontSize->12],
  " simply saves the original values of the specified symbols then clears \
them.\n\n- All the others, which are static scopers, take each local variable \
x, scan the unevaluated body for occurrences of x that are owned by this \
scoping construct, and mark them.  In the case of ",
  StyleBox["Module", "Input",
    FontSize->12],
  ", the marking is visible at top-level:  x is replaced by a new, unique \
symbol x$n.  In the others, ",
  StyleBox["the marking stage cannot be captured on film",
    FontSlant->"Italic"],
  "!"
}], "Text"],

Cell[TextData[{
  "\"in effect\":\n\n  - For ",
  StyleBox["Block", "Input",
    FontSize->12],
  ", the symbols you specified simply have temporary amnesia.  The body is \
executed in an environment where any time these symbols arise in the \
computation, whether they were originally in the text of ",
  StyleBox["body",
    FontSlant->"Italic"],
  "'s code or not, they'll have the temporary values (or lack of values).\n  \
\n  - For static scopers, the unevaluated ",
  StyleBox["body",
    FontSlant->"Italic"],
  " has already had all owned instances marked.  In the case of ",
  StyleBox["Module", "Input",
    FontSize->12],
  ", the dummy symbols will get evaluated when the evaluator reaches them \
[their turn comes up].  In the others, they do instant substitution, ",
  StyleBox["ReplaceAll", "Input",
    FontSize->12],
  "-style (forgetting different levels of scoping respect, please), on the \
body before evaluating, so the \"temporary variables\" are too ephemeral for \
top-level film capture (unless withoff or bruce knows some method I don't)."
}], "Text"],

Cell["Generating list of built-in funcs with Hold attributes", "Text",
  FontSize->16,
  FontWeight->"Bold"],

Cell[BoxData[{
    \(mappings\  = \ 
      Cases[Names["\<System`*\>"], \[IndentingNewLine]symName_String\  \
\[RuleDelayed] \ 
          With[{holdAttrs\  = \ 
                Select[Attributes\  @@ \ ToHeldExpression[symName], \ 
                  StringMatchQ[ToString[#], \ "\<*Hold*\>"] &]}, \ \((Symbol[
                    symName]\  \[Rule] \ holdAttrs)\)\  /; \ 
              holdAttrs\  =!= \ {}]\[IndentingNewLine]]; \), "\n", 
    \({funcsWithHoldAttrs, \ 
        holdAttrs}\  = \ \({Identity[#1], \ Union\  @@ \ #2} &\)\  @@ \ 
        Thread[mappings, \ Rule]; \)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(holdAttrs\)], "Input"],

Cell[BoxData[
    \({HoldAll, HoldAllComplete, HoldFirst, HoldRest, NHoldAll, NHoldFirst, 
      NHoldRest, SequenceHold}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ordinaryHoldFuncs\  = \ 
      First\  /@ \ Select[
          mappings, \[IndentingNewLine]MemberQ[#\[LeftDoubleBracket]2\
\[RightDoubleBracket], \ 
              HoldAll\  | \ HoldAllComplete\  | \ HoldFirst\  | \ 
                HoldRest\  | \ SequenceHold] &]\)], "Input"],

Cell[BoxData[
    \({AbortProtect, AddTo, Alias, And, AppendTo, Attributes, Block, Catch, 
      Check, CheckAbort, CheckAll, Clear, ClearAll, ClearAttributes, Compile, 
      CompiledFunction, CompoundExpression, Condition, ConsoleMessage, 
      ConsolePrint, Context, ContourPlot, Debug, Decrement, DefaultValues, 
      Definition, DensityPlot, Dialog, DivideBy, Do, DownValues, DumpSave, 
      EditDefinition, Exists, FileName, FindMinimum, FindRoot, For, ForAll, 
      FormatValues, FullDefinition, Function, FunctionInterpolation, Hold, 
      HoldComplete, HoldForm, HoldPattern, If, Increment, Information, 
      InterpretationBox, Literal, MakeBoxes, MatchLocalNameQ, 
      MemoryConstrained, Message, MessageName, MessagePacket, Messages, 
      Module, NIntegrate, NProduct, NSum, NValues, Off, On, Or, OwnValues, 
      ParametricPlot, ParametricPlot3D, Parenthesize, Pattern, PatternTest, 
      Play, Plot, Plot3D, PreDecrement, PreIncrement, PrependTo, Product, 
      Protect, Remove, Rule, RuleCondition, RuleDelayed, 
      SampledSoundFunction, Save, Set, SetAttributes, SetDelayed, Stack, 
      StackBegin, StackComplete, StackInhibit, SubtractFrom, SubValues, Sum, 
      Switch, Table, TagSet, TagSetDelayed, TagUnset, TimeConstrained, 
      TimesBy, Timing, Trace, TraceDialog, TracePrint, TraceScan, UnAlias, 
      Unevaluated, Unprotect, Unset, UpSet, UpSetDelayed, UpValues, ValueQ, 
      Which, While, With, $ConditionHold, $Failed}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(nHoldFuncs\  = \ 
      First\  /@ \ Select[
          mappings, \[IndentingNewLine]MemberQ[#\[LeftDoubleBracket]2\
\[RightDoubleBracket], \ 
              NHoldAll\  | \ NHoldFirst\  | \ NHoldRest] &]\)], "Input"],

Cell[BoxData[
    \({Drop, EllipticTheta, EllipticThetaPrime, Extract, HeldPart, MathieuC, 
      MathieuCharacteristicA, MathieuCharacteristicB, MathieuCPrime, 
      MathieuS, MathieuSPrime, Part, PolyGamma, Root, StieltjesGamma, 
      Take}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[Names["\<System`*\>"], \ 
      MemberQ[ToExpression[#, \ InputForm, \ Attributes], \ 
          NHoldAll\  | \ NHoldFirst\  | \ NHoldRest] &]\)], "Input"],

Cell[BoxData[
    \({"Drop", "EllipticTheta", "EllipticThetaPrime", "Extract", "HeldPart", 
      "MathieuC", "MathieuCharacteristicA", "MathieuCharacteristicB", 
      "MathieuCPrime", "MathieuS", "MathieuSPrime", "Part", "PolyGamma", 
      "Root", "StieltjesGamma", "Take"}\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Always anticipate that users might send Unevaluated arguments into your \
function!\n",
  StyleBox["\"Add a mental red flag to your programming habits\"",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
Here I'm referring to any uses you make of the arguments passed to \
your function.  Take this:\
\>", "Text"],

Cell[BoxData[
    \(FindThem[expr_, \ patt_, \ 
        opts___]\  := \[IndentingNewLine]Module[{ ... }, \
\[IndentingNewLine]\(Cases[Unevaluated[expr], \ 
            Unevaluated[
              patt]]; \)\[IndentingNewLine] ... \[IndentingNewLine]]\)], \
"Input"],

Cell[TextData[{
  "If you want your function to \"respect\" ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " as specified by the user, you have to wrap every instance of your pattern \
variables (in the example above, those are ",
  StyleBox["expr", "Input",
    FontSize->12],
  ", ",
  StyleBox["patt", "Input",
    FontSize->12],
  ", and ",
  StyleBox["opts", "Input",
    FontSize->12],
  ") in ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " when you pass it on to some built-in function (or even another top-level \
function).\n\nOtherwise, the arguments carefully protected by the user will \
get evaluated when you operate on them.  I call these ",
  StyleBox["evaluation leaks",
    FontVariations->{"Underline"->True}],
  ", and they're very important to avoid in typesetting or code analysis \
tools."
}], "Text"],

Cell["\<\
Let's say you write a function to insert a given expression between \
every consecutive pair of elements in another expression.  Here's one way you \
might write it:\
\>", "Text"],

Cell[BoxData[{
    \( (*\ First\ version\ *) \[IndentingNewLine]Clear[Intercalate]\), "\n", 
    \(Intercalate[list_, object_] := 
      Insert[list, \ object, \ List /@ Range[2, Length[list]]]\)}], "Input"],

Cell["Works fine for \"ordinary\" expressions:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Intercalate[{1, \ 2, \ 3}, \ x]\)], "Input"],

Cell[BoxData[
    \({1, x, 2, x, 3}\)], "Output"]
}, Open  ]],

Cell["But not for unevaluated stuff:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Intercalate[Hold[1, \ 2, \ 3], \ Unevaluated\ @\ Print[4]]\)], "Input"],

Cell[BoxData[
    \(4\)], "Print"],

Cell[BoxData[
    \(Hold[1, Null, 2, Null, 3]\)], "Output"]
}, Open  ]],

Cell["\<\
So here's another implementation that tries to keep the elements \
unevaluated until the end:\
\>", "Text"],

Cell[BoxData[
    \(\(\( (*\ 
      Second\ version\ *) \)\(\[IndentingNewLine]\)\(Intercalate[list_, 
        object_] := 
      Insert[list, \ Unevaluated[object], \ 
        List /@ Range[2, Length[list]]]\)\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Intercalate[Hold[1, \ 2, \ 3], \ Unevaluated\ @\ Print[4]]\)], "Input"],

Cell[BoxData[
    \(Hold[1, Print[4], 2, Print[4], 3]\)], "Output"]
}, Open  ]],

Cell["\<\
But it doesn't work if the first argument is an unevaluated \
expression:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Intercalate[Unevaluated[2\ *\ 3\ *\ 4], \ x]\)], "Input"],

Cell[BoxData[
    \(24\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "From ",
  StyleBox["Times[2, 3, 4]", "Input",
    FontSize->12],
  ", it should have produced ",
  StyleBox["Times[2, x, 3, x, 4]", "Input",
    FontSize->12],
  ", i.e. ",
  StyleBox["24 x^2", "Input",
    FontSize->12],
  ", but the ",
  StyleBox["Times[2, 3, 4]", "Input",
    FontSize->12],
  " collapsed to 24 too soon."
}], "Text"],

Cell[TextData[{
  "Looking back at our code, we realize that we forgot to wrap all our uses \
of ",
  StyleBox["list", "Input",
    FontSize->12],
  " in ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ":"
}], "Text"],

Cell[BoxData[
    \(\(\( (*\ 
      Third\ version\ *) \)\(\[IndentingNewLine]\)\(Intercalate[list_, 
        object_] := \[IndentingNewLine]Insert[
        Unevaluated[list], \[IndentingNewLine]Unevaluated[
          object], \[IndentingNewLine]List\  /@ \ 
          Range[2, 
            Length\ @\ Unevaluated[list]]\[IndentingNewLine]]\)\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Intercalate[Unevaluated[2\ *\ 3\ *\ 4], \ x]\)], "Input"],

Cell[BoxData[
    \(24\ x\^2\)], "Output"]
}, Open  ]],

Cell[TextData[{
  StyleBox["\[WarningSign]",
    FontSize->24,
    FontColor->RGBColor[1, 0, 0]],
  " Check your ",
  StyleBox["entire function body for all occurrences",
    FontSlant->"Italic"],
  " of the pattern variables, and if they are passed to another function, \
wrap them in Unevaluated!"
}], "Text",
  CellDingbat->None,
  FontWeight->"Bold"],

Cell["\<\
Now, for some functions, notably the whole class of functions we \
might dub \"mathematical functions\", this is probably pedantic and \
inconvenient.  Mathematical functions want to operate on and yield fully \
evaluated algebraic or numeric expressions.\
\>", "Text"],

Cell[TextData[{
  "But for any purely structural command - any auxiliary functions or \
utilities that might fall in the category of \"Programming Functions\" - they \
",
  StyleBox["should be capable of acting on unevaluated expressions",
    FontSlant->"Italic"],
  "!"
}], "Text"],

Cell[TextData[{
  "General Principle:\n\nProtect your uses of the incoming variables from ",
  StyleBox["default interpretation",
    FontSlant->"Italic"],
  " by the language if the arguments are either passed with an explicit flag \
to prevent interpretation (Unevaluated) or the semantics of your function \
naturally doesn't want to use the default interpretation (e.g. a function \
that dumbly counts occurrences of things, who cares if \"things\" includes \
fancy objects like patterns)."
}], "Text",
  FontWeight->"Bold"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Miscellaneous advanced techniques, and subtle topics", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Using tests on patterns:
  /; MyTestQ @ Unevaluated[p]
instead of
  /; MyTestQ[p]\
\>", "Subsubsection"],

Cell["Patterns can be specified in two ways:", "Text"],

Cell[TextData[{
  "(1)  Structure.\nUsing the ",
  StyleBox["Blank", "Input",
    FontSize->12],
  "* family, ",
  StyleBox["Pattern, Alternatives, Repeated", "Input",
    FontSize->12],
  " and ",
  StyleBox["RepeatedNull", "Input",
    FontSize->12],
  ", ",
  StyleBox["Optional", "Input",
    FontSize->12]
}], "Text",
  CellDingbat->"\[FilledSmallCircle]"],

Cell["Examples", "Text"],

Cell[BoxData[
    \(n_Integer\)], "Input"],

Cell[BoxData[
    \({n_Integer, \ x_Real}\)], "Input"],

Cell[BoxData[
    \(f[elems__, \ n_Integer]\)], "Input"],

Cell[BoxData[
    \(_Integer\  | \ _Rational\  | \ _Real\)], "Input"],

Cell[BoxData[
    \({z_Complex, \ {_Real, \ _Real} ... }\)], "Input"],

Cell[TextData[{
  "(2)  Boolean tests.\nUsing ",
  StyleBox["PatternTest", "Input",
    FontSize->12],
  " (",
  StyleBox["patt?func", "Input",
    FontSize->12],
  ") or ",
  StyleBox["Condition", "Input",
    FontSize->12],
  " (",
  StyleBox["patt /; expr", "Input",
    FontSize->12],
  ")"
}], "Text",
  CellDingbat->"\[FilledSmallCircle]"],

Cell["Examples:", "Text"],

Cell[BoxData[
    RowBox[{"n_Integer", 
      StyleBox["?",
        FontColor->RGBColor[0, 0, 1]], 
      StyleBox["Positive",
        FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[BoxData[
    RowBox[{"x_String", 
      StyleBox["?",
        FontColor->RGBColor[0, 0, 1]], 
      StyleBox["MyTest",
        FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[TextData[{
  StyleBox["PatternTest", "Input",
    FontSize->12],
  " (",
  StyleBox["patt?func", "Input",
    FontSize->12],
  ") and ",
  StyleBox["Condition", "Input",
    FontSize->12],
  " (",
  StyleBox["patt /; expr", "Input",
    FontSize->12],
  "), are unlike the components of the pattern language because they perform \
",
  StyleBox["evaluation",
    FontSlant->"Italic"],
  " on the prospective match, or parts thereof, instead of simply checking ",
  StyleBox["structure",
    FontSlant->"Italic"],
  ".  By default, they will evaluate each and every prospective match.  If \
you're searching something that contains function bodies, rules, or any sort \
of unevaluated code, then these tests will evaluate those things while \
checking if they match!  This is often the wrong thing to do, and if the \
unevaluated code contains things like assignments, it will change the state \
of your ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " session.\n\nHardly anyone is accustomed to this subtlety of pattern \
tests, so you have to train yourself to remember it, setting a mental flag on \
your usage of ",
  StyleBox["PatternTest", "Input",
    FontSize->12],
  " and ",
  StyleBox["Condition", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[TextData[{
  "Here's a surprisingly realistic example of how casual use of ",
  StyleBox["PatternTest", "Input",
    FontSize->12],
  " can cause code to execute.  The user wants to find all ",
  StyleBox["Cell", "Input",
    FontSize->12],
  " options whose values are themselves lists with suboptions."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
    \(thingsThatAreSubOptions\  = \ 
      Cases[\[IndentingNewLine]Options[
          Cell], \[IndentingNewLine]\((Rule\  | \ RuleDelayed)\)[optName_, \ 
          optValue_List\  /; \ 
            Not\ @\ FreeQ[
                optValue, \ _?OptionQ]]\[IndentingNewLine]]; \)], "Input"],

Cell[BoxData[
    RowBox[{
      ErrorBox[\(Slot[1]\)], 
      ErrorBox[\(Slot[1]\)]}]], "Input"],

Cell[TextData[{
  "Whoa, why did red-underlined ",
  StyleBox["Slot[1]", "Input",
    FontSize->12],
  " get written to a cell??\n\nAnswer:  One of the options of ",
  StyleBox["Cell", "Input",
    FontSize->12],
  " is ",
  StyleBox["ButtonBoxOptions", "Input",
    FontSize->12],
  ", which provides defaults for things like ",
  StyleBox["ButtonData :> data", "Input",
    FontSize->12],
  " and ",
  StyleBox["ButtonFunction :> func", "Input",
    FontSize->12],
  ".  Notice that the latter are delayed rules, because their rhs contains \
code!  Our condition on ",
  StyleBox["optValue_List", "Input",
    FontSize->12],
  " used the very aggressive ",
  StyleBox["FreeQ", "Input",
    FontSize->12],
  " test, which searches all levels of an expression for a match of the \
pattern.  The pattern we asked ",
  StyleBox["FreeQ", "Input",
    FontSize->12],
  " to search for was ",
  StyleBox["_?OptionQ", "Input",
    FontSize->12],
  ", which evaluates ",
  StyleBox["OptionQ", "Input",
    FontSize->12],
  " on every prospective match!  Since ",
  StyleBox["FreeQ", "Input",
    FontSize->12],
  " tests every subexpression from the top on down to the atoms, this \
evaluates code inside of ",
  StyleBox["ButtonFunction", "Input",
    FontSize->12],
  ", particularly a pure function involving ",
  StyleBox["NotebookApply", "Input",
    FontSize->12],
  ".  That's what printed then ",
  StyleBox["Slot[1]", "Input",
    FontSize->12],
  "'s."
}], "Text"],

Cell["\<\
Here are a few other common types of tests.  The first in each pair \
carelessly evaluates; the second is the corrected version with no evaluation \
leaks.\
\>", "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[{
    \( (*\ \(Incorrect\)\(:\)\ *) \[IndentingNewLine]things_List\  /; \ 
      Length[things]\  \[GreaterEqual] \ 
        2\[IndentingNewLine]\n (*\ \(Correct\)\(:\)\ *) \), "\n", 
    \(things_List\  /; \ 
      Length\ @\ Unevaluated[things]\  \[GreaterEqual] \ 2\)}], "Input"],

Cell[BoxData[{
    \( (*\ \(Incorrect\)\(:\)\ *) \[IndentingNewLine]num_?
      NumberQ\[IndentingNewLine]\n (*\ \(Correct\)\(:\)\ *) \), "\n", 
    \(num_?\((Function[e, \ NumberQ\ @\ Unevaluated[e], \ 
          HoldAllComplete])\)\)}], "Input"],

Cell[BoxData[{
    \( (*\ \(Incorrect\)\(:\)\ *) \[IndentingNewLine]args___\  /; \ 
      FreeQ[{args}, \ _Rule\  | \ _RuleDelayed]\[IndentingNewLine]\n (*\ \
\(Correct\)\(:\)\ *) \), "\n", 
    \(args___\  /; \ 
      FreeQ[Unevaluated[{args}], \ _Rule\  | \ _RuleDelayed]\)}], "Input"],

Cell[TextData[{
  "Personally, I hate the appearance of ",
  StyleBox["x?(Function[...])", "Input",
    FontSize->12],
  " so I either define my own ",
  StyleBox["HoldAll", "Input",
    FontSize->12],
  " or ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " test function to make the code clearer:"
}], "Text"],

Cell[BoxData[
    \(x_?HeldNumberQ\)], "Input"],

Cell[TextData[{
  "or I use ",
  StyleBox["Condition", "Input",
    FontSize->12],
  ", where I can make the code a little clearer by naming the parts I want to \
reference."
}], "Text"],

Cell[TextData[{
  "In general, the handful of ",
  StyleBox["raw objects",
    FontSlant->"Italic"],
  " of ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " are often specified using these patterns:\n\n  x_Integer\n  x_Rational\n  \
x_Real\n  x_Complex\n  \n  x_String\n  x_Symbol\n  \n  Technically, these \
patterns catch more than the raw atoms.  ",
  StyleBox["Integer[0, \"Hello\"]", "Input",
    FontSize->12],
  " is a perfectly valid expression whose head is ",
  StyleBox["Integer", "Input",
    FontSize->12],
  ", therefore it matches ",
  StyleBox["_", "Input",
    FontSize->12],
  StyleBox["Integer", "Input",
    FontSize->12],
  ".  In practice, rarely do these occur, so it would just make code scary \
looking to use anything other than the common and almost-correct idioms.\n  \n\
    But if you're writing advanced code that must not have any evaluation \
leaks, e.g. typesetting code or code analysis tools, you need the \
bullet-proof version."
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell["Here's a template for bullet-proof pattern test:", "Text"],

Cell[BoxData[
    RowBox[{
      StyleBox[
        RowBox[{"x_", 
          StyleBox["RawType",
            FontSlant->"Italic"]}]], " ", 
      StyleBox["/;",
        FontColor->RGBColor[0, 0, 1]], 
      StyleBox[" ",
        FontColor->RGBColor[0, 0, 1]], 
      StyleBox[\(AtomQ\ @\ Unevaluated[x]\),
        FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[TextData[{
  "where ",
  StyleBox["RawType", "Input",
    FontSize->12,
    FontSlant->"Italic"],
  " \[Element] {",
  StyleBox["Integer", "Input",
    FontSize->12],
  ", ",
  StyleBox["Rational", "Input",
    FontSize->12],
  ", ",
  StyleBox["Real", "Input",
    FontSize->12],
  ", ",
  StyleBox["Complex", "Input",
    FontSize->12],
  ", ",
  StyleBox["Symbol", "Input",
    FontSize->12],
  ", ",
  StyleBox["String", "Input",
    FontSize->12],
  "}."
}], "Text"],

Cell[TextData[{
  "Often you won't need the ",
  StyleBox["AtomQ", "Input",
    FontSize->12],
  " test, though, because you're selecting matches using one of the family of \
commands that takes a level specification, such as ",
  StyleBox["Replace", "Input",
    FontSize->12],
  ", ",
  StyleBox["Cases", "Input",
    FontSize->12],
  ", or ",
  StyleBox["MemberQ", "Input",
    FontSize->12],
  ".  In that case, you can give a levelspec of ",
  StyleBox["{-1}", "Input",
    FontSize->12],
  ", or ",
  StyleBox["{Infinity}", "Input",
    FontSize->12],
  ", to the main command, which is a nice way to restrict the search space, \
relieving some of the burden on the actual pattern.\n\nTemplate examples:"
}], "Text"],

Cell[BoxData[
    \(Cases[expr, \ 
      s_Symbol\  \[RuleDelayed] \ Context[s], \ {\(-1\)}]\)], "Input"],

Cell[BoxData[
    \(MemberQ[expr, \ s_String\ , \ {\(-1\)}]\)], "Input"],

Cell[BoxData[
    \(Replace[expr, \ 
      x_Real\  \[RuleDelayed] \ Sqrt[x], \ {\(-1\)}]\)], "Input"],

Cell[TextData[{
  "You could define test to detect potentially dangerous subexpressions if \
you wish.  Look for expressions whose head has a ",
  StyleBox["Hold", "Input",
    FontSize->12],
  "* attribute:"
}], "Text",
  CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[{
    \(Attributes[HoldQ]\  = \ HoldAllComplete; \[IndentingNewLine]\), "\n", 
    \(HoldQ[
        s_Symbol\  /; \ 
          AtomQ\ @\ Unevaluated[s]]\  := \[IndentingNewLine]MemberQ[
        Attributes[s], \ 
        HoldFirst\  | \ HoldRest\  | \ HoldAll\  | \ 
          HoldAllComplete]\)}], "Input"],

Cell[BoxData[
    \(ContainsUnevaluatedQ[expr_]\  := \[IndentingNewLine]MemberQ[
        Unevaluated[expr], \ h_Symbol?HoldQ[___], \ {0, \ \(-1\)}, \ 
        Heads \[Rule] True]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ContainsUnevaluatedQ[Options[Cell]]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Open  ]],

Cell["\<\
You can also return a list of them to see what you're up against:\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[Options[Cell], \ h_Symbol?HoldQ[___], \ {0, \ \(-1\)}, \ 
      Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \({"\[Rule]" \[RuleDelayed] "->", "\[RuleDelayed]" \[RuleDelayed] ":>", 
      "\[LessEqual]" \[RuleDelayed] "<=", 
      "\[GreaterEqual]" \[RuleDelayed] ">=", 
      "\[NotEqual]" \[RuleDelayed] "!=", "\[Equal]" \[RuleDelayed] "==", 
      ConversionRules \[RuleDelayed] None, TaggingRules \[RuleDelayed] None, 
      LayoutInformation \[RuleDelayed] None, 
      DragAndDropFunction \[RuleDelayed] None, 
      CoordinateDisplayFunction \[RuleDelayed] Identity, 
      CounterFunction \[RuleDelayed] Identity, 
      CounterData \[RuleDelayed] Identity, 
      FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
              Placeholder]}] &, 
      ButtonFunction \[RuleDelayed] \
\((FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
                  Placeholder]}] &)\), ButtonData \[RuleDelayed] Automatic, 
      FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
              Placeholder]}] &, 
      ButtonFunction \[RuleDelayed] \
\((FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
                  Placeholder]}] &)\), ButtonData \[RuleDelayed] Automatic, 
      ButtonFunction \[RuleDelayed] Null, 
      TrackingFunction \[RuleDelayed] Null, 
      ButtonData \[RuleDelayed] Automatic, 
      GridDefaultElement \[RuleDelayed] \[Placeholder]}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Obviously, many of these ",
  StyleBox["RuleDelayed", "Input",
    FontSize->12],
  "'s have atoms as their parts and are safe to evaluate, so you might want \
to prune this down to more dangerous things:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[%, \ _\  \[RuleDelayed] \ _String\  | \ _Symbol]\)], "Input"],

Cell[BoxData[
    \({FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
              Placeholder]}] &, 
      ButtonFunction \[RuleDelayed] \
\((FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
                  Placeholder]}] &)\), 
      FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
              Placeholder]}] &, 
      ButtonFunction \[RuleDelayed] \
\((FrontEndExecute[{FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #1, 
                  Placeholder]}] &)\)}\)], "Output"]
}, Open  ]],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
  "Sometimes you want to specify that an argument not match a pattern, and \
since there is no ",
  StyleBox["PatternNot", "Input",
    FontSize->12],
  " primitive in the language, you need to do this in a Boolean test.  One \
way is to use ",
  StyleBox["MatchQ", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[BoxData[
    RowBox[{"f", "[", 
      RowBox[{"x_", ",", " ", 
        RowBox[{"y_", " ", 
          StyleBox["/;",
            FontColor->RGBColor[0, 0, 1]], 
          StyleBox[" ",
            FontColor->RGBColor[0, 0, 1]], 
          RowBox[{
            StyleBox["Not",
              FontColor->RGBColor[0, 0, 1]], 
            StyleBox[" ",
              FontColor->RGBColor[0, 0, 1]], 
            StyleBox["@",
              FontColor->RGBColor[0, 0, 1]], 
            StyleBox[" ",
              FontColor->RGBColor[0, 0, 1]], 
            RowBox[{
              StyleBox["MatchQ",
                FontColor->RGBColor[0, 0, 1]], 
              StyleBox["[",
                FontColor->RGBColor[0, 0, 1]], 
              RowBox[{
                StyleBox[\(Unevaluated[y]\),
                  FontColor->RGBColor[0, 0, 1]], ",", " ", "_List"}], 
              "]"}]}]}]}], "]"}]], "Input"],

Cell[TextData[{
  StyleBox["\[WarningSign]",
    FontSize->24,
    FontColor->RGBColor[1, 0, 0]],
  StyleBox["  ",
    FontColor->RGBColor[1, 0, 0]],
  StyleBox["Warning",
    FontSlant->"Italic",
    FontColor->RGBColor[1, 0, 0]],
  StyleBox[":  Before Version 3, you were virtually guaranteed that _Symbol \
would match only the atomic data type of 'symbols',  But in Versions 3 and \
beyond, Symbol can also be used as a function, e.g. Symbol[\"a\"] \
\[DoubleLongRightArrow] a, so if your program is dealing with unevaluated \
input or code of any sort, you have to now deal with the fact that _Symbol \
matches two classes of legitimate expressions:  atomic symbols, and calls of \
the Symbol function.  Example:",
    FontColor->RGBColor[1, 0, 0]]
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Symbol["\<a\>"]\)], "Input"],

Cell[BoxData[
    \(a\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Through[{FullForm, \ AtomQ, \ Head}[%]]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        TagBox[
          StyleBox["a",
            ShowSpecialCharacters->False,
            ShowStringCharacters->True,
            NumberMarks->True],
          FullForm], ",", "True", ",", "Symbol"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
  "A weird pseudo-Symbol that you might run in to:  if you remove a symbol \
which is still currently in use in some definitions, then it will be replaced \
by an entity which prints like ",
  StyleBox["Removed[\"symName\"]", "Input",
    FontSize->12],
  " and which is considered an atom and has head ",
  StyleBox["Symbol", "Input",
    FontSize->12],
  ".  It will ",
  StyleBox["match _Symbol", "Input",
    FontSize->12],
  ", and you can assign to it, look up its information or context, and most \
if not all that other stuff you can do with symbols, but it's strange because \
it has no input form (that I know of) and ",
  StyleBox["Names[]", "Input",
    FontSize->12],
  " seems unaware of its existence in any context, let alone the one that ",
  StyleBox["Context", "Input",
    FontSize->12],
  " claims it is in."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x\  = \ doomed; \ 0\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Open  ]],

Cell[BoxData[
    \(Remove["\<doomed\>"]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x\)], "Input"],

Cell[BoxData[
    TagBox[\(Removed["doomed"]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Through[{FullForm, \ AtomQ, \ Head}[x]]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        TagBox[
          StyleBox[
            TagBox[\(Removed["\<doomed\>"]\),
              False,
              Editable->False],
            ShowSpecialCharacters->False,
            ShowStringCharacters->True,
            NumberMarks->True],
          FullForm], ",", "True", ",", "Symbol"}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(isSymbol[_Symbol]\  = \ True; \), "\n", 
    \(isSymbol[_]\  = \ False; \), "\n", 
    \(isSymbol[x]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Evaluate[x]\  = \ 777\)], "Input"],

Cell[BoxData[
    \(777\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Unevaluated\ @\ Information[x]\  /. \ OwnValues[x]\)], "Input"],

Cell[BoxData[
    \("Global`doomed"\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {
                  RowBox[{
                    TagBox[\(Removed["doomed"]\),
                      False,
                      Editable->False], "=", "777"}]}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ 
        Removed[ "doomed"]],
      Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Unevaluated\ @\ Context[x]\  /. \ OwnValues[x]\)], "Input"],

Cell[BoxData[
    \("Global`"\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Characters[%14]\  // FullForm\)], "Input"],

Cell[BoxData[
    TagBox[
      StyleBox[\(List["\<G\>", "\<l\>", "\<o\>", "\<b\>", "\<a\>", "\<l\>", "\
\<`\>"]\),
        ShowSpecialCharacters->False,
        ShowStringCharacters->True,
        NumberMarks->True],
      FullForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Names["\<Global`*oom*\>"]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Names["\<Global`*\>"]\)], "Input"],

Cell[BoxData[
    \({"a", "isSymbol", "x"}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[Names[], \ StringMatchQ[#, \ "\<*doom*\>"] &]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Trott-Strzebonski method for In-Place Evaluation", "Subsubsection"],

Cell[TextData[{
  "One of the all-time cleverest idioms I've seen; this was discovered by \
Michael Trott and Adam Strzebonski a few years ago.  The template is a rule \
of the following form:\n\n   ",
  StyleBox["lhs :> With[{eval = lhs}, eval /; True]", "Input",
    FontSize->12]
}], "Text"],

Cell["\<\
Suppose you want to replace a bunch of things inside a held \
expression, and have the replacements evaluate.  You don't want to evaluate \
the whole, just the pieces that are targeted.\
\>", "Text"],

Cell[BoxData[
    \(SeedRandom[2^51]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(jaggedTable\  = \ 
      Table[Random[
          Integer, \ {0, \ 5}], \ {Random[Integer, \ {1, \ 4}]}, \ {Random[
            Integer, \ {1, \ 4}]}, \ {Random[
            Integer, \ {1, \ 4}]}]\)], "Input"],

Cell[BoxData[
    \({{{1, 4, 4, 0}, {2, 0, 1}, {1, 1}, {5, 5, 2, 2}}, {{0, 5, 5}}, {{5, 1, 
          3}, {4, 1}}, {{3, 3, 4, 0}, {5, 2}, {4, 2, 0}, {2, 5}}}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(heldTable\  = \ Apply[Hold, \ jaggedTable, \ {0, \ 1}]\)], "Input"],

Cell[BoxData[
    \(Hold[Hold[{1, 4, 4, 0}, {2, 0, 1}, {1, 1}, {5, 5, 2, 2}], 
      Hold[{0, 5, 5}], Hold[{5, 1, 3}, {4, 1}], 
      Hold[{3, 3, 4, 0}, {5, 2}, {4, 2, 0}, {2, 5}]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(heldTable\  = \ Apply[Plus, \ heldTable, \ {\(-2\)}]\)], "Input"],

Cell[BoxData[
    \(Hold[Hold[1 + 4 + 4 + 0, 2 + 0 + 1, 1 + 1, 5 + 5 + 2 + 2], 
      Hold[0 + 5 + 5], Hold[5 + 1 + 3, 4 + 1], 
      Hold[3 + 3 + 4 + 0, 5 + 2, 4 + 2 + 0, 2 + 5]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(heldTable\  /. \ 
      p_Plus\  \[RuleDelayed] \ 
        With[{eval\  = \ p}, \ eval\  /; \ True]\)], "Input"],

Cell[BoxData[
    \(Hold[Hold[9, 3, 2, 14], Hold[10], Hold[9, 5], 
      Hold[10, 7, 6, 7]]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "You can also do this with ",
  StyleBox["ReplacePart", "Input",
    FontSize->12],
  ", but it's harder to code, and has a worse time and space complexity for a \
large number of substitutions (and using ",
  StyleBox["Fold", "Input",
    FontSize->12],
  " with ",
  StyleBox["ReplacePart", "Input",
    FontSize->12],
  " would be O(n^2))."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["My Block trick for trapping calls to built-in functions", \
"Subsubsection"],

Cell["Prototypical example to use as a template:", "Text"],

Cell[BoxData[{
    \(wasProtected\  = \ Unprotect[Get]; \[IndentingNewLine]\), "\n", 
    \($TrapGet\  = \ True; \[IndentingNewLine]\), "\n", 
    \(g_Get\  /; \ $TrapGet\  := \[IndentingNewLine]Block[{$TrapGet\  = \ 
            False}, \[IndentingNewLine]Print[
          Unevaluated[
            g], \ "\< was evaluated!\>"]; \[IndentingNewLine]g\
\[IndentingNewLine]]\[IndentingNewLine]\), "\n", 
    \(Protect\  @@ \ wasProtected; \)}], "Input"],

Cell[TextData[{
  "You are quite free to make the lhs of the rule more complicated; perhaps \
you need to name some arguments of ",
  StyleBox["Get", "Input",
    FontSize->12],
  " so you can refer to them.  The same template applies. For instance:"
}], "Text"],

Cell[BoxData[
    \(Get[filename_String, \ 
          opts___]\  /; \ $TrapGet\  := \[IndentingNewLine]Block[{$TrapGet\  \
= \ False}, \[IndentingNewLine]If[
          StringMatchQ[
            filename, \ "\<http://*\>"], \[IndentingNewLine]Run["\<wget\>", \ 
            filename], \[IndentingNewLine]Get[
            filename]\[IndentingNewLine]]\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  "I recommend that you hang the condition ",
  StyleBox["/; $TrapGet", "Input",
    FontSize->12],
  " off the lhs, not the rhs, because then you can revoke the definition by \
plopping the whole lhs into an ",
  StyleBox["Unset", "Input",
    FontSize->12],
  " command:"
}], "Text"],

Cell[BoxData[
    \(Unset[Get[filename_String, \ opts___]\  /; \ $TrapGet]\)], "Input"],

Cell["\<\


\
\>", "Text"],

Cell["\<\
Also, an important limitation:  can't be used for recursive, e.g. \
Module as tgayley pointed out?\
\>", "Text"],

Cell["\<\
But using a count variable and checking EvenQ[count++] might do it \
if there is one recursion per trap?  Never did find out for sure.\
\>", "Text"],

Cell["\<\
Another limitation:  probably can't trap SetDelayed, Condition, \
Block, or CompoundExpression with it.  Try to find work-around for this!

One alternative to Block is my old method:  manually set and unset the var, \
must wrap in CheckAbort to prevent dirty state change.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["One-step evaluation using expr /. DownValues[f], and family.", \
"Subsubsection"],

Cell[TextData[{
  "Let's say you want to ",
  StyleBox["Map", "Input",
    FontSize->12],
  " or ",
  StyleBox["MapAt", "Input",
    FontSize->12],
  " an existing function f deep into a held expression, and simply have f \
perform its rewrite rule on the argument without any more evaluation."
}], "Text"],

Cell[BoxData[{
    \(ClearAll[f, array]\[IndentingNewLine]\), "\n", 
    \(f[x_]\  := \ x\  + \ x^2\  + \ x^3\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(array\  = \ Array[Subtract, \ {3, \ 4}]\)], "Input"],

Cell[BoxData[
    \({{0, \(-1\), \(-2\), \(-3\)}, {1, 0, \(-1\), \(-2\)}, {2, 1, 
        0, \(-1\)}}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[f, \ Hold[Evaluate[\ array\ ]], \ {3}]\)], "Input"],

Cell[BoxData[
    \(Hold[{{f[0], f[\(-1\)], f[\(-2\)], f[\(-3\)]}, {f[1], f[0], f[\(-1\)], 
          f[\(-2\)]}, {f[2], f[1], f[0], f[\(-1\)]}}]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(%\  /. \ DownValues[f]\)], "Input"],

Cell[BoxData[
    \(Hold[{{0 + 0\^2 + 
            0\^3, \(-1\) + \((\(-1\))\)\^2 + \((\(-1\))\)\^3, \(-2\) + \
\((\(-2\))\)\^2 + \((\(-2\))\)\^3, \(-3\) + \((\(-3\))\)\^2 + \
\((\(-3\))\)\^3}, {1 + 1\^2 + 1\^3, 
          0 + 0\^2 + 
            0\^3, \(-1\) + \((\(-1\))\)\^2 + \((\(-1\))\)\^3, \(-2\) + \
\((\(-2\))\)\^2 + \((\(-2\))\)\^3}, {2 + 2\^2 + 2\^3, 1 + 1\^2 + 1\^3, 
          0 + 0\^2 + 
            0\^3, \(-1\) + \((\(-1\))\)\^2 + \((\(-1\))\)\^3}}]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "You could write a routine to extract the names of symbols occurring at \
each stage, accumulate their various *Values into a list, and apply that list \
of rules.  To attempt to simulate the evaluator, you'd have to make sure ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " fires befored ",
  StyleBox["DownValues", "Input",
    FontSize->12],
  ", and lots of details like that.\n\nYou could ",
  StyleBox["Nest", "Input",
    FontSize->12],
  " this routine n times, or do ",
  StyleBox["FixedPoint", "Input",
    FontSize->12],
  " of it to crudely simulate the evaluator."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Traps used for tracing should not evaluate what they print or \
memoize\
\>", "Subsubsection"],

Cell["\<\
Many of you have written things like this to see when a rule fires:\
\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll["\<f\>"]\), "\n", 
    \(f[a_, \ b_]\  /; \ \((Print["\<a = \>", \ a]; \ 
          Print["\<b = \>", \ b]; \ False)\)\  := \ $Failed\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[Unevaluated[1\  + \ 2], \ Unevaluated[3*4]]\)], "Input"],

Cell[BoxData[
    InterpretationBox[\("a = "\[InvisibleSpace]3\),
      SequenceForm[ "a = ", 3],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[\("b = "\[InvisibleSpace]12\),
      SequenceForm[ "b = ", 12],
      Editable->False]], "Print"],

Cell[BoxData[
    \(f[Unevaluated[1 + 2], Unevaluated[3\ 4]]\)], "Output"]
}, Open  ]],

Cell["\<\
But sometimes f,whether it's yours or an internal function, will \
encounter things that are bits of unevaluated code, say in the middle of an \
evaluation, or during a trace, or whatever.  This is a case where you want to \
prevent evaluation:\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll["\<f\>"]\), "\n", 
    \(f[a_, \ b_]\  /; \ \((Print["\<a = \>", \ Unevaluated[a]]; \ 
          Print["\<b = \>", \ Unevaluated[b]]; \ 
          False)\)\  := \ $Failed\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[Unevaluated[1\  + \ 2], \ Unevaluated[3*4]]\)], "Input"],

Cell[BoxData[
    InterpretationBox[\("a = "\[InvisibleSpace]\(1 + 2\)\),
      SequenceForm[ "a = ", 
        Plus[ 1, 2]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[\("b = "\[InvisibleSpace]\(3\ 4\)\),
      SequenceForm[ "b = ", 
        Times[ 3, 4]],
      Editable->False]], "Print"],

Cell[BoxData[
    \(f[Unevaluated[1 + 2], Unevaluated[3\ 4]]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Or if you really want to be defensive and are concerned that ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " might fire on ",
  StyleBox["Print[thing]", "Input",
    FontSize->12],
  " before ",
  StyleBox["Print", "Input",
    FontSize->12],
  " can evaluate, use two levels of protection.  Either ",
  StyleBox["Unevaluated @ HoldForm[thing] ", "Input",
    FontSize->12],
  "or ",
  StyleBox["HoldForm @ HoldForm[thing]", "Input",
    FontSize->12],
  ", or perhaps best of all, define yourself a ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " version of ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
How to pass arguments to HoldAllComplete functions (such as \
HoldComplete itself), since Evaluate no longer forces evaluation:  Function \
@@, With, Block, Replace, ReplacePart\
\>", "Subsubsection"],

Cell[TextData[{
  ".Of course, ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " is a bit of a pain, since when you're writing code in a module and need \
to pass the ",
  StyleBox["value",
    FontSlant->"Italic"],
  " of a variable, like ",
  StyleBox["myexpr", "Input",
    FontSize->12],
  ", into it, you can't use ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " like you could with ",
  StyleBox["Hold", "Input",
    FontSize->12],
  " and friends.  So here is a list of some techniques for passing into ",
  StyleBox["HoldAllComplete", "Input",
    FontSize->12],
  " wrappers:"
}], "Text"],

Cell["Passing it fully evaluated:", "Text"],

Cell[BoxData[
    \(\(MyHolder[#] &\)\ [myexpr]\)], "Input"],

Cell[BoxData[
    \(MyHolder\  @@ \ {myexpr}\)], "Input"],

Cell[BoxData[
    \(With[{myexpr\  = \ myexpr}, \[IndentingNewLine]MyHolder[
        myexpr]\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  "As always, you can temporarily neutralize with ",
  StyleBox["Block", "Input",
    FontSize->12],
  ".  Keep in mind that ",
  StyleBox["myHolder", "Input",
    FontSize->12],
  " would prevent ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " of its arguments from firing, but will not do so when you ",
  StyleBox["Block", "Input",
    FontSize->12],
  " it, therefore it's possible for this to not be equivalent to the other \
techniques."
}], "Text"],

Cell[BoxData[
    \(Block[{myHolder}, \[IndentingNewLine]myHolder[
        myexpr]\[IndentingNewLine]]\)], "Input"],

Cell[TextData[{
  StyleBox["Replace", "Input",
    FontSize->12],
  " is useful if you know that your ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  " contains a particular form, e.g. ",
  StyleBox["s_Symbol", "Input",
    FontSize->12],
  " or ",
  StyleBox["Plus[a_, b_]", "Input",
    FontSize->12],
  ", for instance if it came out of ",
  StyleBox["MakeExpression", "Input",
    FontSize->12],
  ", or ",
  StyleBox["Extract", "Input",
    FontSize->12],
  " or ",
  StyleBox["ToExpression", "Input",
    FontSize->12],
  " with the container argument specified to be ",
  StyleBox["HoldComplete", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[BoxData[
    \(Replace[HoldComplete[myexpr], \ 
      HoldComplete[Plus[a_, \ b_]]\  \[RuleDelayed] \ 
        MyHolder[a, \ b]]\)], "Input"],

Cell["\<\
Padding it one-step evaluated, or passing something you construct \
from parts:\
\>", "Text"],

Cell[BoxData[
    \(With[{e\  := \ Plus[a, \ b]}, \[IndentingNewLine]MyHolder[
        e]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(MyHolder[myexpr]\  /. \ OwnValues[myexpr]\)], "Input"],

Cell[BoxData[
    \(ReplacePart[HoldComplete[myexpr], \ 
      Unevaluated\ @\ Plus[a, b], \ {{1}}]\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      This\ will\ let\ Set\ decide\ what\ to\ \(\(evaluate\)\(:\)\)\ *) \)\(\
\[IndentingNewLine]\)\(Set\  @@ \ 
      HoldComplete[f[x_, \ 0], \ rhs]\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Use strings for symbol names or even to store FullForm of an \
expression\
\>", "Subsubsection"],

Cell[TextData[{
  "This is the extreme of preventing interpretation of your expressions:  \
making them no longer expressions, but raw strings.\n\nThis is mainly useful \
for persistent storage, and is essentially what ",
  StyleBox["Save", "Input",
    FontSize->12],
  " does when it writes out code."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
You can even use Unevaluated as a persistent head, but I don't \
recommend it for most cases.\
\>", "Subsubsection"],

Cell[TextData[{
  "Since ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  " is strange in acting differently depending on whether it's there before \
or after arg evaluation, I don't recommend using it as a persistent head \
until you're ",
  StyleBox["very",
    FontSlant->"Italic"],
  " comfortable with it.  Even then, someone who has to modify your code \
later might not be comfortable with it and might easily be misled into \
treating it like an ordinary head.\n\nIts ordinary use as an ephemeral flag \
is fine, and not likely to cause you any problems."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Related (another example of a more general issue) issue:  when to \
wrap incoming argument in Verbatim in case it's a pattern and you're going to \
pass it to a function that does use pattern semantics when given \
patterns.\
\>", "Subsubsection"],

Cell[TextData[{
  "A related issue:  if you are quite sure that an argument should always be \
considered a literal expression, never a pattern, then you'd better \
anticipate that a user could pass a pattern there.  For instance, I once \
wrote a function to take a list and give you a list of all its distinct \
elements together with the count of their occurrences in the list:  ",
  StyleBox["Frequencies", "Input",
    FontSize->12],
  "."
}], "Text"],

Cell[BoxData[
    \(\(\(Frequencies[
        list_]\  := \[IndentingNewLine]\({#, \ Count[list, \ #]} &\)\  /@ \ 
        Union[list]; \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      Never\ mind\ that\ this\ isn' 
        t\ as\ efficient\ as\ it\ could\ be\ due\ to\ ' Count'\ rescanning\ ' 
        list'\ *) \)\)\)], "Input"],

Cell["This doesn't work if list contains some patterns!", "Text"],

Cell[BoxData[
    \(list\  = \ {1, \ 2.5, \ 
        2.5, \ _Integer, \ _Integer, \ _Real, \ _Real, \ _Real, \ _Symbol, \ \
_Symbol, \ _Symbol}; \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Frequencies[list]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {2.5`, 2}, {_Integer, 1}, {_Real, 2}, {_Symbol, 
        0}}\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Well, shucks!  ",
  StyleBox["_Symbol", "Input",
    FontSize->12],
  " occurs 3 times, not 0!  And this result implies that the original list \
had a total of 6 elements:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Plus\  @@ \ Map[Last, \ %]\)], "Input"],

Cell[BoxData[
    \(6\)], "Output"]
}, Open  ]],

Cell["when we know darn well it had more:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Length[list]\)], "Input"],

Cell[BoxData[
    \(11\)], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Some examples", "Section"],

Cell["\<\
I will add quite a few examples from my scratch work in the next \
revision of this document.\
\>", "Text"],

Cell[CellGroupData[{

Cell["\<\
To analyze the code in a package:  read the statements from the \
file as a list of Hold[stmt]\
\>", "Subsubsection"],

Cell["\<\
Suppose you want to analyze usages in the package, e.g. \
symbols.\
\>", "Text"],

Cell[BoxData[
    \(heldStatements\  = \ 
      ReadList["\<MyPackage.m\>", \ Hold[Expression]]; \)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
HoldCompleteForm:  a non-printing variant of HoldComplete (just as \
HoldForm is to Hold)\
\>", "Subsubsection"],

Cell[TextData[{
  StyleBox["MyHoldForm", "Input",
    FontSize->12],
  " is a little stronger than ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  ":\n\n(1)  Prevents ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " and ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " wrappers on arguments intact (and ",
  StyleBox["Unevaluated", "Input",
    FontSize->12],
  ", but that's as much because of not calling any code on the args)\n\n(2)  \
Prevents  ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  " of its arguments from firing and thus rewriting it."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Attributes[HoldCompleteForm]\  = \ HoldAllComplete\n\), "\n", 
    \(Format[HoldCompleteForm[expr_]]\  := \ 
      HoldForm\ @\ HoldForm[expr]\)}], "Input"],

Cell[BoxData[
    \(HoldAllComplete\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "This relies on the simple fact that anything deeper than level 1 in a \
holding container won't be touched even if it's wrapped in ",
  StyleBox["Evaluate", "Input",
    FontSize->12],
  " or ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  ", or has ",
  StyleBox["UpValues", "Input",
    FontSize->12],
  ".  For instance:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Hold[{Evaluate[1\  + \ 2], \ Sequence[3, \ 4]}]\)], "Input"],

Cell[BoxData[
    \(Hold[{Evaluate[1 + 2], Sequence[3, 4]}]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Function[e, \ {Evaluate[1\  + \ 2], \ Sequence[3, \ 4]}]\)], "Input"],

Cell[BoxData[
    \(Function[e, {Evaluate[1 + 2], Sequence[3, 4]}]\)], "Output"]
}, Open  ]],

Cell[TextData[{
  "Hence, there was no need to use two layers of ",
  StyleBox["Hold", "Input",
    FontSize->12],
  ".  I could have used a non-holding head at the inner level (though of \
course I want it to be non-printing):"
}], "Text"],

Cell[BoxData[
    \(Format[HoldCompleteForm[expr_]]\  := \ 
      HoldForm\ @\ SequenceForm[expr]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? \ HoldCompleteForm\)], "Input"],

Cell[BoxData[
    \("Global`HoldCompleteForm"\)], "Print"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[HoldCompleteForm] = {HoldAllComplete}\)},
          {" "},
          {GridBox[{
                {\(MakeBoxes[expr_, FormatType_] ^:= 
                    "Format"["HoldForm"["SequenceForm"[expr]], 
                      FormatType]\)},
                {" "},
                {\("Format"[expr_] := "HoldForm"["SequenceForm"[expr]]\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ HoldCompleteForm],
      Editable->False]], "Print"]
}, Open  ]],

Cell[TextData[{
  "But just as for ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  ", several args don't work.  If you want n args, you maybe want ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " as the displayed head, not sure.  If so, don't use ",
  StyleBox["SequenceForm", "Input",
    FontSize->12],
  ".\n(Though ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  " of n args may have printed as ",
  StyleBox["Sequence", "Input",
    FontSize->12],
  " in V2, not sure.)"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(HoldCompleteForm[Evaluate[1\  + \ 2], \ Sequence[3, \ 4]]\)], "Input"],

Cell[BoxData[
    \(HoldCompleteForm[Evaluate[1 + 2], Sequence[3, 4]]\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \({HoldCompleteForm[Evaluate[1\  + \ 2]], \ 
      HoldCompleteForm[Sequence[3, \ 4]]}\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        TagBox[
          InterpretationBox[\(Evaluate[1 + 2]\),
            SequenceForm[ 
              Evaluate[ 
                Plus[ 1, 2]]],
            Editable->False],
          HoldForm], ",", 
        TagBox[
          InterpretationBox[\(Sequence[3, 4]\),
            SequenceForm[ 
              Sequence[ 3, 4]],
            Editable->False],
          HoldForm]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Another implementation of the ",
  StyleBox["Format", "Input",
    FontSize->12],
  " rule (following ",
  StyleBox["$Output", "Input",
    FontSize->12],
  " to be pedantic):\n[",
  StyleBox["Hmmm, ", "EditorialRemark"],
  StyleBox["$Output", "Input",
    FontSize->12],
  StyleBox[" likely has ", "EditorialRemark"],
  StyleBox["FormatType->StandardForm", "Input",
    FontSize->12],
  StyleBox[", which isn't what we want?  Revisit this...]", 
    "EditorialRemark"]
}], "Text"],

Cell[BoxData[
    \(Format[HoldCompleteForm[expr_]]\  := \ 
      ToString[Unevaluated[expr], \ 
        Sequence\  @@ \ Options[$Output]]\)], "Input"],

Cell[BoxData[
    \(Format[HoldCompleteForm[expr_]]\  := \ 
      ToString[Unevaluated[expr], \ OutputForm, \ 
        Sequence\  @@ \ Options[$Output]]\)], "Input"],

Cell[TextData[{
  "But this implementation is not as correct, cuz it formats it as a string, \
whereas normally ",
  StyleBox["HoldForm", "Input",
    FontSize->12],
  " would format as an expression, which makes a difference if the output \
format is typeset.  The \"output format\" could be either the default (in ",
  StyleBox["$Output", "Input",
    FontSize->12],
  ") or a one-shot deal like ",
  StyleBox["expr //TraditionalForm", "Input",
    FontSize->12],
  ", at run-time, you just don't know."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Set and SetDelayed can be more flexible.", "Subsubsection"],

Cell[TextData[{
  "- Evaluate certain parts of ",
  StyleBox["SetDelayed", "Input",
    FontSize->12],
  " rhs as exceptions\n- Don't evaluate certain parts of ",
  StyleBox["Set", "Input",
    FontSize->12],
  " rhs as exceptions\n\n- Properly scope pattern vars of ",
  StyleBox["Set", "Input",
    FontSize->12],
  " when conducting assignment to be stored."
}], "Text"],

Cell["\<\
I will include these examples in the next revision of this \
document.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Temporarily deactivate kernel functions that open files for writing\
\
\>", "Subsubsection"],

Cell["\<\
Here's a crude \"scoping construct\" that deactivates file writing \
commands for the duration of execution of its body:\
\>", "Text"],

Cell[BoxData[{
    \($FileWritingFunctions = {Put, PutAppend, OpenWrite, OpenAppend, Save, 
        DumpSave, \ Splice, Display, Write, WriteString, 
        Encode}; \[IndentingNewLine]\), "\n", 
    \(Attributes[NoFiles] = HoldFirst; \[IndentingNewLine]\), "\n", 
    \(NoFiles[expr_] := 
      Unevaluated@Block[$FileWritingFunctions, expr] /. 
        OwnValues[$FileWritingFunctions]\)}], "Input"],

Cell["\<\
This is untested, but it illustrates that you can implement your \
own debugging/testing tools with the techniques described in this talk.\
\>", \
"Text"]
}, Closed]]
}, Open  ]]
},
FrontEndVersion->"4.0 for X",
ScreenRectangle->{{0, 1024}, {0, 768}},
AutoGeneratedPackage->None,
Evaluator->"Local 4.0.2 (6S, 1 Sep 1999)",
WindowSize->{642, 688},
WindowMargins->{{Automatic, 164}, {Automatic, 0}},
PrintingPageRange->{Automatic, Automatic},
PrintingOptions->{"PaperSize"->{612, 792},
"PaperOrientation"->"Portrait",
"PostScriptOutputFile":>FrontEnd`FileName[{$RootDirectory, "mnt", "floppy"}, \
"UnevaluatedExpressions.nb.ps", CharacterEncoding -> "ISO8859-1"],
"Magnification"->1},
CellLabelAutoDelete->True,
SpellingOptions->{"AlwaysStop"->"RepeatedWords"},
SpellingDictionaries->{"CorrectWords"->{
  "heldElems", "elems", "patts", "factored", "held", "initializations", 
    "expr", "iterand", "iter", "heldIterSpecs", "heldVars", "heldVarList", 
    "ilim", "Expr", "canonicalize", "Withoff", "Maeder", "formatter", "eval", 
    "ni", "Canonicalize", "args", "Args", "heldArgs", "heldPairs", "ls", 
    "heldDegrees", "ints", "nonInts", "heldDegreesNew", "heldSum", "argrx", 
    "arguments", "myexpr", "rhs", "Delaix", "Robby", "vars", "attrs", "exprs",
     "fmt", "boxexpr", "cuz", "heldStatements", "var", "lhs", "subexprs", 
    "Hold'ing", "coeff", "outer", "levelspecs", "partspec", "posList", 
    "Trott", "Strzebonski", "jaggedTable", "heldTable", "meta", "for", 
    "wasProtected", "wget", "tgayley", "num", "x$", "Gotchas", "ssle", 
    "Withoff's", "Hmmm", "subexpr", "vs.", "args.", "by", "recursors", 
    "iterator", "rgs", "control", "uneval'n", "localvars", "vn", "scopers", 
    "x$n.", "withoff", "funcs", "mappings", "sym", "Attrs", "holdAttrs", 
    "ordinaryHoldFuncs", "expr.", "nHoldFuncs", "patt", "exprs.", "obj", 
    "hmm", "scratchwork", "n_Integer", "func", "x_String", "things_List", 
    "opt", "x", "x_RawType", "where", "isSymbol", "oom", "isn'", "rescanning",
     "list", "when", "musings", "x$10", "dgbgn", "dgend", "res", "cont", 
    "Dir", "heldDegreesSorted", "heldDegreesGrouped", "Na", "demystify", "ei",
     "spam", "Villegas"}},
Magnification->1,
StyleDefinitions -> Notebook[{
  
  Cell[CellGroupData[{
  Cell["Style Definitions", "Subtitle"],
  
  Cell["\<\
Modify the definitions below to change the default appearance of \
all cells in a given style.  Make modifications to any definition using \
commands in the Format menu.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell["Style Environment Names", "Section"],
  
  Cell[StyleData[All, "Working"],
    PageWidth->WindowWidth,
    CellLabelMargins->{{12, Inherited}, {Inherited, Inherited}},
    ScriptMinSize->9],
  
  Cell[StyleData[All, "Presentation"],
    PageWidth->WindowWidth,
    CellLabelMargins->{{24, Inherited}, {Inherited, Inherited}},
    ScriptMinSize->12],
  
  Cell[StyleData[All, "Condensed"],
    PageWidth->WindowWidth,
    CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},
    ScriptMinSize->8],
  
  Cell[StyleData[All, "Printout"],
    PageWidth->PaperWidth,
    CellLabelMargins->{{2, Inherited}, {Inherited, Inherited}},
    ScriptMinSize->5,
    PrivateFontOptions->{"FontType"->"Outline"}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Notebook Options", "Section"],
  
  Cell["\<\
The options defined for the style below will be used at the \
Notebook level.\
\>", "Text"],
  
  Cell[StyleData["Notebook"],
    PageHeaders->{{Cell[ 
            TextData[ {
              CounterBox[ "Page"]}], "PageNumber"], None, Cell[ 
            TextData[ {
              ValueBox[ "FileName"]}], "Header"]}, {Cell[ 
            TextData[ {
              ValueBox[ "FileName"]}], "Header"], None, Cell[ 
            TextData[ {
              CounterBox[ "Page"]}], "PageNumber"]}},
    CellFrameLabelMargins->6,
    StyleMenuListing->None]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Styles for Headings", "Section"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Title"],
    CellMargins->{{12, Inherited}, {20, 40}},
    CellGroupingRules->{"TitleGrouping", 0},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Title",
    CounterAssignments->{{"Section", 0}, {"Equation", 0}, {"Figure", 0}, {
        "Subtitle", 0}, {"Subsubtitle", 0}},
    FontFamily->"Helvetica",
    FontSize->36,
    FontWeight->"Bold"],
  
  Cell[StyleData["Title", "Presentation"],
    CellMargins->{{24, 10}, {20, 40}},
    LineSpacing->{1, 0},
    FontSize->44],
  
  Cell[StyleData["Title", "Condensed"],
    CellMargins->{{8, 10}, {4, 8}},
    FontSize->20],
  
  Cell[StyleData["Title", "Printout"],
    CellMargins->{{2, 10}, {12, 30}},
    FontSize->24]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subtitle"],
    CellMargins->{{12, Inherited}, {20, 15}},
    CellGroupingRules->{"TitleGrouping", 10},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Subtitle",
    CounterAssignments->{{"Section", 0}, {"Equation", 0}, {"Figure", 0}, {
        "Subsubtitle", 0}},
    FontFamily->"Helvetica",
    FontSize->30,
    FontWeight->"Bold"],
  
  Cell[StyleData["Subtitle", "Presentation"],
    CellMargins->{{24, 10}, {20, 20}},
    LineSpacing->{1, 0},
    FontSize->36],
  
  Cell[StyleData["Subtitle", "Condensed"],
    CellMargins->{{8, 10}, {4, 4}},
    FontSize->14],
  
  Cell[StyleData["Subtitle", "Printout"],
    CellMargins->{{2, 10}, {12, 8}},
    FontSize->18]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subsubtitle"],
    CellMargins->{{12, Inherited}, {20, 15}},
    CellGroupingRules->{"TitleGrouping", 20},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Subsubtitle",
    CounterAssignments->{{"Section", 0}, {"Equation", 0}, {"Figure", 0}},
    FontFamily->"Helvetica",
    FontSize->24,
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["Subsubtitle", "Presentation"],
    CellMargins->{{24, 10}, {20, 20}},
    LineSpacing->{1, 0},
    FontSize->24],
  
  Cell[StyleData["Subsubtitle", "Condensed"],
    CellMargins->{{8, 10}, {8, 8}},
    FontSize->12],
  
  Cell[StyleData["Subsubtitle", "Printout"],
    CellMargins->{{2, 10}, {12, 8}},
    FontSize->14]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Section"],
    CellDingbat->"\[FilledSquare]",
    CellMargins->{{25, Inherited}, {8, 24}},
    CellGroupingRules->{"SectionGrouping", 30},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Section",
    CounterAssignments->{{"Subsection", 0}, {"Subsubsection", 0}},
    FontFamily->"Helvetica",
    FontSize->24,
    FontWeight->"Bold"],
  
  Cell[StyleData["Section", "Presentation"],
    CellMargins->{{40, 10}, {11, 32}},
    LineSpacing->{1, 0},
    FontSize->24],
  
  Cell[StyleData["Section", "Condensed"],
    CellMargins->{{18, Inherited}, {6, 12}},
    FontSize->12],
  
  Cell[StyleData["Section", "Printout"],
    CellMargins->{{13, 0}, {7, 22}},
    FontSize->14]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subsection"],
    CellDingbat->"\[FilledSmallSquare]",
    CellMargins->{{22, Inherited}, {8, 20}},
    CellGroupingRules->{"SectionGrouping", 40},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Subsection",
    CounterAssignments->{{"Subsubsection", 0}},
    FontFamily->"Times",
    FontSize->18,
    FontWeight->"Bold"],
  
  Cell[StyleData["Subsection", "Presentation"],
    CellMargins->{{36, 10}, {11, 32}},
    LineSpacing->{1, 0},
    FontSize->22],
  
  Cell[StyleData["Subsection", "Condensed"],
    CellMargins->{{16, Inherited}, {6, 12}},
    FontSize->12],
  
  Cell[StyleData["Subsection", "Printout"],
    CellMargins->{{9, 0}, {7, 22}},
    FontSize->12]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subsubsection"],
    CellDingbat->"\[FilledSmallSquare]",
    CellMargins->{{22, Inherited}, {8, 18}},
    CellGroupingRules->{"SectionGrouping", 50},
    PageBreakBelow->False,
    DefaultNewInlineCellStyle->"None",
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"Subsubsection",
    FontFamily->"Times",
    FontSize->16,
    FontWeight->"Bold"],
  
  Cell[StyleData["Subsubsection", "Presentation"],
    CellMargins->{{34, 10}, {11, 26}},
    LineSpacing->{1, 0},
    FontSize->18],
  
  Cell[StyleData["Subsubsection", "Condensed"],
    CellMargins->{{17, Inherited}, {6, 12}},
    FontSize->10],
  
  Cell[StyleData["Subsubsection", "Printout"],
    CellMargins->{{9, 0}, {7, 14}},
    FontSize->11]
  }, Closed]]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell["Styles for Body Text", "Section"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Text"],
    CellMargins->{{12, 10}, {7, 7}},
    InputAutoReplacements->{"TeX"->StyleBox[ 
            RowBox[ {"T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "LaTeX"->StyleBox[ 
            RowBox[ {"L", 
              StyleBox[ 
                AdjustmentBox[ 
                "A", BoxMargins -> {{-0.35999999999999999, \
-0.10000000000000001}, {0, 0}}, BoxBaselineShift -> -0.20000000000000001], 
                FontSize -> Smaller], "T", 
              AdjustmentBox[ 
              "E", BoxMargins -> {{-0.074999999999999997, \
-0.085000000000000006}, {0, 0}}, BoxBaselineShift -> 0.5], "X"}]], 
        "mma"->"Mathematica", "Mma"->"Mathematica", "MMA"->"Mathematica"},
    Hyphenation->True,
    LineSpacing->{1, 3},
    CounterIncrements->"Text",
    FontSize->14],
  
  Cell[StyleData["Text", "Presentation"],
    CellMargins->{{24, 10}, {10, 10}},
    LineSpacing->{1, 5},
    FontSize->16],
  
  Cell[StyleData["Text", "Condensed"],
    CellMargins->{{8, 10}, {6, 6}},
    LineSpacing->{1, 1},
    FontSize->11],
  
  Cell[StyleData["Text", "Printout"],
    CellMargins->{{2, 2}, {6, 6}},
    TextJustification->0.5,
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SmallText"],
    CellMargins->{{12, 10}, {6, 6}},
    DefaultNewInlineCellStyle->"None",
    Hyphenation->True,
    LineSpacing->{1, 3},
    LanguageCategory->"NaturalLanguage",
    CounterIncrements->"SmallText",
    FontFamily->"Helvetica",
    FontSize->10],
  
  Cell[StyleData["SmallText", "Presentation"],
    CellMargins->{{24, 10}, {8, 8}},
    LineSpacing->{1, 5},
    FontSize->12],
  
  Cell[StyleData["SmallText", "Condensed"],
    CellMargins->{{8, 10}, {5, 5}},
    LineSpacing->{1, 2},
    FontSize->9],
  
  Cell[StyleData["SmallText", "Printout"],
    CellMargins->{{2, 2}, {5, 5}},
    TextJustification->0.5,
    FontSize->7]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Styles for Input/Output", "Section"],
  
  Cell["\<\
The cells in this section define styles used for input and output \
to the kernel.  Be careful when modifying, renaming, or removing these \
styles, because the front end associates special meanings with these style \
names. Some attributes for these styles are actually set in FormatType Styles \
(in the last section of this stylesheet). \
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Input"],
    CellMargins->{{45, 10}, {5, 7}},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->"Formula",
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    LinebreakAdjustments->{0.85, 2, 10, 0, 1},
    CounterIncrements->"Input",
    FontWeight->"Bold"],
  
  Cell[StyleData["Input", "Presentation"],
    CellMargins->{{72, Inherited}, {8, 10}},
    LineSpacing->{1, 0},
    FontSize->16],
  
  Cell[StyleData["Input", "Condensed"],
    CellMargins->{{40, 10}, {2, 3}},
    FontSize->11],
  
  Cell[StyleData["Input", "Printout"],
    CellMargins->{{39, 0}, {4, 6}},
    LinebreakAdjustments->{0.85, 2, 10, 1, 1},
    FontSize->9]
  }, Closed]],
  
  Cell[StyleData["InputOnly"],
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    CellHorizontalScrolling->True,
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->"Formula",
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    LinebreakAdjustments->{0.85, 2, 10, 0, 1},
    CounterIncrements->"Input",
    StyleMenuListing->None,
    FontWeight->"Bold"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Output"],
    CellMargins->{{47, 10}, {7, 5}},
    CellEditDuplicate->True,
    CellGroupingRules->"OutputGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    DefaultFormatType->DefaultOutputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->"Formula",
    FormatType->InputForm,
    CounterIncrements->"Output"],
  
  Cell[StyleData["Output", "Presentation"],
    CellMargins->{{72, Inherited}, {10, 8}},
    LineSpacing->{1, 0},
    FontSize->16],
  
  Cell[StyleData["Output", "Condensed"],
    CellMargins->{{41, Inherited}, {3, 2}},
    FontSize->11],
  
  Cell[StyleData["Output", "Printout"],
    CellMargins->{{39, 0}, {6, 4}},
    FontSize->9]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Message"],
    CellMargins->{{45, Inherited}, {Inherited, Inherited}},
    CellGroupingRules->"OutputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    DefaultFormatType->DefaultOutputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    FormatType->InputForm,
    CounterIncrements->"Message",
    StyleMenuListing->None,
    FontSize->11,
    FontColor->RGBColor[0, 0, 1]],
  
  Cell[StyleData["Message", "Presentation"],
    CellMargins->{{72, Inherited}, {Inherited, Inherited}},
    LineSpacing->{1, 0},
    FontSize->16],
  
  Cell[StyleData["Message", "Condensed"],
    CellMargins->{{41, Inherited}, {Inherited, Inherited}},
    FontSize->11],
  
  Cell[StyleData["Message", "Printout"],
    CellMargins->{{39, Inherited}, {Inherited, Inherited}},
    FontSize->7,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Print"],
    CellMargins->{{45, Inherited}, {Inherited, Inherited}},
    CellGroupingRules->"OutputGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    DefaultFormatType->DefaultOutputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    FormatType->InputForm,
    CounterIncrements->"Print",
    StyleMenuListing->None],
  
  Cell[StyleData["Print", "Presentation"],
    CellMargins->{{72, Inherited}, {Inherited, Inherited}},
    LineSpacing->{1, 0},
    FontSize->16],
  
  Cell[StyleData["Print", "Condensed"],
    CellMargins->{{41, Inherited}, {Inherited, Inherited}},
    FontSize->11],
  
  Cell[StyleData["Print", "Printout"],
    CellMargins->{{39, Inherited}, {Inherited, Inherited}},
    FontSize->8]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Graphics"],
    CellMargins->{{4, Inherited}, {Inherited, Inherited}},
    CellGroupingRules->"GraphicsGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    DefaultFormatType->DefaultOutputFormatType,
    LanguageCategory->None,
    FormatType->InputForm,
    CounterIncrements->"Graphics",
    ImageMargins->{{43, Inherited}, {Inherited, 0}},
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontSize->10],
  
  Cell[StyleData["Graphics", "Presentation"],
    ImageMargins->{{62, Inherited}, {Inherited, 0}}],
  
  Cell[StyleData["Graphics", "Condensed"],
    ImageMargins->{{38, Inherited}, {Inherited, 0}},
    Magnification->0.6],
  
  Cell[StyleData["Graphics", "Printout"],
    ImageMargins->{{30, Inherited}, {Inherited, 0}},
    Magnification->0.8]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["CellLabel"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->9,
    FontColor->RGBColor[0, 0, 1]],
  
  Cell[StyleData["CellLabel", "Presentation"],
    FontSize->12],
  
  Cell[StyleData["CellLabel", "Condensed"],
    FontSize->9],
  
  Cell[StyleData["CellLabel", "Printout"],
    FontFamily->"Courier",
    FontSize->8,
    FontSlant->"Italic",
    FontColor->GrayLevel[0]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Inline Formatting", "Section"],
  
  Cell["\<\
These styles are for modifying individual words or letters in a \
cell exclusive of the cell tag.\
\>", "Text"],
  
  Cell[StyleData["RM"],
    StyleMenuListing->None,
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["BF"],
    StyleMenuListing->None,
    FontWeight->"Bold"],
  
  Cell[StyleData["IT"],
    StyleMenuListing->None,
    FontSlant->"Italic"],
  
  Cell[StyleData["TR"],
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["TI"],
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["TB"],
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["TBI"],
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Bold",
    FontSlant->"Italic"],
  
  Cell[StyleData["MR"],
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["MO"],
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["MB"],
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["MBO"],
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Bold",
    FontSlant->"Italic"],
  
  Cell[StyleData["SR"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["SO"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["SB"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["SBO"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontWeight->"Bold",
    FontSlant->"Italic"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SO10"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["SO10", "Printout"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->7,
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["SO10", "EnhancedPrintout"],
    StyleMenuListing->None,
    FontFamily->"Futura",
    FontSize->7,
    FontWeight->"Plain",
    FontSlant->"Italic"]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Formulas and Programming", "Section"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["InlineFormula"],
    CellMargins->{{10, 4}, {0, 8}},
    CellHorizontalScrolling->True,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    LanguageCategory->"Formula",
    ScriptLevel->1,
    SingleLetterItalics->True],
  
  Cell[StyleData["InlineFormula", "Presentation"],
    CellMargins->{{24, 10}, {10, 10}},
    LineSpacing->{1, 5},
    FontSize->16],
  
  Cell[StyleData["InlineFormula", "Condensed"],
    CellMargins->{{8, 10}, {6, 6}},
    LineSpacing->{1, 1},
    FontSize->11],
  
  Cell[StyleData["InlineFormula", "Printout"],
    CellMargins->{{2, 0}, {6, 6}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["DisplayFormula"],
    CellMargins->{{42, Inherited}, {Inherited, Inherited}},
    CellHorizontalScrolling->True,
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    LanguageCategory->"Formula",
    ScriptLevel->0,
    SingleLetterItalics->True,
    UnderoverscriptBoxOptions->{LimitsPositioning->True}],
  
  Cell[StyleData["DisplayFormula", "Presentation"],
    LineSpacing->{1, 5},
    FontSize->16],
  
  Cell[StyleData["DisplayFormula", "Condensed"],
    LineSpacing->{1, 1},
    FontSize->11],
  
  Cell[StyleData["DisplayFormula", "Printout"],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Program"],
    CellFrame->{{0, 0}, {0.5, 0.5}},
    CellMargins->{{10, 4}, {0, 8}},
    CellHorizontalScrolling->True,
    Hyphenation->False,
    LanguageCategory->"Formula",
    ScriptLevel->1,
    FontFamily->"Courier"],
  
  Cell[StyleData["Program", "Presentation"],
    CellMargins->{{24, 10}, {10, 10}},
    LineSpacing->{1, 5},
    FontSize->16],
  
  Cell[StyleData["Program", "Condensed"],
    CellMargins->{{8, 10}, {6, 6}},
    LineSpacing->{1, 1},
    FontSize->11],
  
  Cell[StyleData["Program", "Printout"],
    CellMargins->{{2, 0}, {6, 6}},
    FontSize->9]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Hyperlink Styles", "Section"],
  
  Cell["\<\
The cells below define styles useful for making hypertext \
ButtonBoxes.  The \"Hyperlink\" style is for links within the same Notebook, \
or between Notebooks.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Hyperlink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonNote->ButtonData}],
  
  Cell[StyleData["Hyperlink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["Hyperlink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["Hyperlink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell["\<\
The following styles are for linking automatically to the on-line \
help system.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["MainBookLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "MainBook", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["MainBookLink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["MainBookLink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["MainBookLink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["AddOnsLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontFamily->"Courier",
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "AddOns", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["AddOnsLink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["AddOnsLink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["AddOnsLink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["RefGuideLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontFamily->"Courier",
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "RefGuide", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["RefGuideLink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["RefGuideLink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["RefGuideLink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["GettingStartedLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "GettingStarted", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["GettingStartedLink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["GettingStartedLink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["GettingStartedLink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["OtherInformationLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "OtherInformation", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["OtherInformationLink", "Presentation"],
    FontSize->16],
  
  Cell[StyleData["OtherInformationLink", "Condensed"],
    FontSize->11],
  
  Cell[StyleData["OtherInformationLink", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Styles for Headers and Footers", "Section"],
  
  Cell[StyleData["Header"],
    CellMargins->{{0, 0}, {4, 1}},
    DefaultNewInlineCellStyle->"None",
    LanguageCategory->"NaturalLanguage",
    StyleMenuListing->None,
    FontSize->10,
    FontSlant->"Italic"],
  
  Cell[StyleData["Footer"],
    CellMargins->{{0, 0}, {0, 4}},
    DefaultNewInlineCellStyle->"None",
    LanguageCategory->"NaturalLanguage",
    StyleMenuListing->None,
    FontSize->9,
    FontSlant->"Italic"],
  
  Cell[StyleData["PageNumber"],
    CellMargins->{{0, 0}, {4, 1}},
    StyleMenuListing->None,
    FontFamily->"Times",
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Palette Styles", "Section"],
  
  Cell["\<\
The cells below define styles that define standard \
ButtonFunctions, for use in palette buttons.\
\>", "Text"],
  
  Cell[StyleData["Paste"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookApply[ 
          FrontEnd`InputNotebook[ ], #, After]}]&)}],
  
  Cell[StyleData["Evaluate"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookApply[ 
          FrontEnd`InputNotebook[ ], #, All], 
        SelectionEvaluate[ 
          FrontEnd`InputNotebook[ ], All]}]&)}],
  
  Cell[StyleData["EvaluateCell"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookApply[ 
          FrontEnd`InputNotebook[ ], #, All], 
        FrontEnd`SelectionMove[ 
          FrontEnd`InputNotebook[ ], All, Cell, 1], 
        FrontEnd`SelectionEvaluateCreateCell[ 
          FrontEnd`InputNotebook[ ], All]}]&)}],
  
  Cell[StyleData["CopyEvaluate"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`SelectionCreateCell[ 
          FrontEnd`InputNotebook[ ], All], 
        FrontEnd`NotebookApply[ 
          FrontEnd`InputNotebook[ ], #, All], 
        FrontEnd`SelectionEvaluate[ 
          FrontEnd`InputNotebook[ ], All]}]&)}],
  
  Cell[StyleData["CopyEvaluateCell"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`SelectionCreateCell[ 
          FrontEnd`InputNotebook[ ], All], 
        FrontEnd`NotebookApply[ 
          FrontEnd`InputNotebook[ ], #, All], 
        FrontEnd`SelectionEvaluateCreateCell[ 
          FrontEnd`InputNotebook[ ], All]}]&)}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Placeholder Styles", "Section"],
  
  Cell["\<\
The cells below define styles useful for making placeholder \
objects in palette templates.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Placeholder"],
    Placeholder->True,
    StyleMenuListing->None,
    FontSlant->"Italic",
    FontColor->RGBColor[0.890623, 0.864698, 0.384756],
    TagBoxOptions->{Editable->False,
    Selectable->False,
    StripWrapperBoxes->False}],
  
  Cell[StyleData["Placeholder", "Presentation"]],
  
  Cell[StyleData["Placeholder", "Condensed"]],
  
  Cell[StyleData["Placeholder", "Printout"]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["PrimaryPlaceholder"],
    StyleMenuListing->None,
    DrawHighlighted->True,
    FontSlant->"Italic",
    Background->RGBColor[0.912505, 0.891798, 0.507774],
    TagBoxOptions->{Editable->False,
    Selectable->False,
    StripWrapperBoxes->False}],
  
  Cell[StyleData["PrimaryPlaceholder", "Presentation"]],
  
  Cell[StyleData["PrimaryPlaceholder", "Condensed"]],
  
  Cell[StyleData["PrimaryPlaceholder", "Printout"]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["FormatType Styles", "Section"],
  
  Cell["\<\
The cells below define styles that are mixed in with the styles \
of most cells.  If a cell's FormatType matches the name of one of the styles \
defined below, then that style is applied between the cell's style and its \
own options. This is particularly true of Input and Output.\
\>", "Text"],
  
  Cell[StyleData["CellExpression"],
    PageWidth->Infinity,
    CellMargins->{{6, Inherited}, {Inherited, Inherited}},
    ShowCellLabel->False,
    ShowSpecialCharacters->False,
    AllowInlineCells->False,
    Hyphenation->False,
    AutoItalicWords->{},
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontSize->12,
    Background->GrayLevel[1]],
  
  Cell[StyleData["InputForm"],
    InputAutoReplacements->{},
    AllowInlineCells->False,
    Hyphenation->False,
    StyleMenuListing->None,
    FontFamily->"Courier"],
  
  Cell[StyleData["OutputForm"],
    PageWidth->Infinity,
    TextAlignment->Left,
    LineSpacing->{0.6, 1},
    StyleMenuListing->None,
    FontFamily->"Courier"],
  
  Cell[StyleData["StandardForm"],
    InputAutoReplacements->{
      "->"->"\[Rule]", ":>"->"\[RuleDelayed]", "<="->"\[LessEqual]", 
        ">="->"\[GreaterEqual]", "!="->"\[NotEqual]", "=="->"\[Equal]", 
        Inherited},
    LineSpacing->{1.25, 0},
    StyleMenuListing->None,
    FontFamily->"Courier"],
  
  Cell[StyleData["TraditionalForm"],
    InputAutoReplacements->{
      "->"->"\[Rule]", ":>"->"\[RuleDelayed]", "<="->"\[LessEqual]", 
        ">="->"\[GreaterEqual]", "!="->"\[NotEqual]", "=="->"\[Equal]", 
        Inherited},
    LineSpacing->{1.25, 0},
    SingleLetterItalics->True,
    TraditionalFunctionNotation->True,
    DelimiterMatching->None,
    StyleMenuListing->None],
  
  Cell["\<\
The style defined below is mixed in to any cell that is in an \
inline cell within another.\
\>", "Text"],
  
  Cell[StyleData["InlineCell"],
    TextAlignment->Left,
    ScriptLevel->1,
    StyleMenuListing->None],
  
  Cell[StyleData["InlineCellEditing"],
    StyleMenuListing->None,
    Background->RGBColor[1, 0.749996, 0.8]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Automatic Styles", "Section"],
  
  Cell["\<\
The cells below define styles that are used to affect the display \
of certain types of objects in typeset expressions.  For example, \
\"UnmatchedBracket\" style defines how unmatched bracket, curly bracket, and \
parenthesis characters are displayed (typically by coloring them to make them \
stand out).\
\>", "Text"],
  
  Cell[StyleData["UnmatchedBracket"],
    StyleMenuListing->None,
    FontColor->RGBColor[0.760006, 0.330007, 0.8]]
  }, Closed]]
  }, Open  ]]
  }]
]


(***********************************************************************
Cached data follows.  If you edit this Notebook file directly, not using
Mathematica, you must remove the line containing CacheID at the top of 
the file.  The cache data will then be recreated when you save this file 
from within Mathematica.
***********************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{
Cell[1717, 49, 97, 2, 115, "Input"],
Cell[1817, 53, 73, 4, 42, "Author"],
Cell[1893, 59, 945, 16, 178, "Abstract"],
Cell[2841, 77, 154, 3, 59, "Input",
  InitializationCell->True],

Cell[CellGroupData[{
Cell[3020, 84, 60, 0, 61, "Section"],

Cell[CellGroupData[{
Cell[3105, 88, 50, 0, 47, "Subsubsection"],
Cell[3158, 90, 751, 20, 200, "Text"],
Cell[3912, 112, 412, 11, 71, "Text"],
Cell[4327, 125, 163, 3, 75, "Input"],

Cell[CellGroupData[{
Cell[4515, 132, 64, 1, 27, "Input"],
Cell[4582, 135, 195, 3, 47, "Output"]
}, Open  ]],
Cell[4792, 141, 356, 11, 52, "Text"],

Cell[CellGroupData[{
Cell[5173, 156, 71, 1, 27, "Input"],
Cell[5247, 159, 117, 2, 49, "Output"]
}, Open  ]],
Cell[5379, 164, 295, 6, 71, "Text"],
Cell[5677, 172, 687, 15, 240, "Text"],
Cell[6367, 189, 1607, 53, 232, "Text"],
Cell[7977, 244, 382, 7, 90, "Text"],

Cell[CellGroupData[{
Cell[8384, 255, 351, 11, 43, "Input"],
Cell[8738, 268, 50, 1, 27, "Output"]
}, Open  ]],
Cell[8803, 272, 551, 12, 90, "Text"],

Cell[CellGroupData[{
Cell[9379, 288, 482, 15, 43, "Input"],
Cell[9864, 305, 1763, 53, 128, "Output"]
}, Open  ]],
Cell[11642, 361, 617, 14, 175, "Text"],
Cell[12262, 377, 1111, 26, 261, "Text"],
Cell[13376, 405, 47, 5, 71, "Text"],
Cell[13426, 412, 479, 10, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[13942, 427, 120, 3, 54, "Subsubsection"],
Cell[14065, 432, 185, 4, 52, "Text"],
Cell[14253, 438, 79, 1, 27, "Input"],
Cell[14335, 441, 861, 16, 204, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[15233, 462, 51, 0, 33, "Subsubsection"],
Cell[15287, 464, 127, 5, 33, "Text"],
Cell[15417, 471, 227, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[15669, 481, 73, 1, 27, "Input"],
Cell[15745, 484, 38, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[15820, 490, 107, 2, 27, "Input"],
Cell[15930, 494, 35, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[16002, 500, 79, 1, 27, "Input"],
Cell[16084, 503, 53, 1, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[16174, 509, 169, 5, 27, "Input"],
Cell[16346, 516, 43, 1, 27, "Output"]
}, Open  ]],
Cell[16404, 520, 410, 11, 71, "Text"],
Cell[16817, 533, 112, 1, 33, "Text"],
Cell[16932, 536, 71, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[17028, 541, 77, 1, 27, "Input"],
Cell[17108, 544, 67, 1, 27, "Output"]
}, Open  ]],
Cell[17190, 548, 247, 9, 33, "Text"],

Cell[CellGroupData[{
Cell[17462, 561, 64, 1, 27, "Input"],
Cell[17529, 564, 167, 3, 39, "Message"],
Cell[17699, 569, 167, 3, 39, "Message"],
Cell[17869, 574, 167, 3, 39, "Message"],
Cell[18039, 579, 165, 3, 39, "Message"],
Cell[18207, 584, 73, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[18317, 590, 103, 2, 27, "Input"],
Cell[18423, 594, 117, 2, 39, "Print"],
Cell[18543, 598, 509, 14, 59, "Print"],
Cell[19055, 614, 139, 2, 39, "Print"],
Cell[19197, 618, 414, 12, 23, "Print"]
}, Open  ]],
Cell[19626, 633, 960, 27, 219, "Text"],

Cell[CellGroupData[{
Cell[20611, 664, 180, 3, 75, "Input"],
Cell[20794, 669, 47, 1, 27, "Output"]
}, Open  ]],
Cell[20856, 673, 405, 8, 71, "Text"],
Cell[21264, 683, 180, 3, 43, "Input"],

Cell[CellGroupData[{
Cell[21469, 690, 46, 1, 27, "Input"],
Cell[21518, 693, 117, 2, 39, "Print"],
Cell[21638, 697, 509, 14, 59, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[22184, 716, 80, 1, 27, "Input"],
Cell[22267, 719, 327, 6, 75, "Output"]
}, Open  ]],
Cell[22609, 728, 95, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[22729, 735, 145, 3, 43, "Input"],
Cell[22877, 740, 1263, 25, 189, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[24189, 771, 177, 5, 54, "Subsubsection"],
Cell[24369, 778, 1157, 28, 259, "Text"],
Cell[25529, 808, 153, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[25707, 817, 88, 1, 27, "Input"],
Cell[25798, 820, 38, 1, 27, "Output"]
}, Open  ]],
Cell[25851, 824, 208, 8, 33, "Text"],

Cell[CellGroupData[{
Cell[26084, 836, 81, 1, 27, "Input"],
Cell[26168, 839, 38, 1, 27, "Output"]
}, Open  ]],
Cell[26221, 843, 528, 13, 109, "Text"],

Cell[CellGroupData[{
Cell[26774, 860, 66, 1, 27, "Input"],
Cell[26843, 863, 61, 1, 44, "Output"]
}, Open  ]],
Cell[26919, 867, 234, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[27178, 877, 56, 1, 27, "Input"],
Cell[27237, 880, 56, 1, 29, "Output"]
}, Open  ]],
Cell[27308, 884, 62, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[27395, 888, 63, 1, 27, "Input"],
Cell[27461, 891, 58, 1, 27, "Output"]
}, Open  ]],
Cell[27534, 895, 158, 5, 33, "Text"],
Cell[27695, 902, 651, 18, 166, "Text"],
Cell[28349, 922, 377, 14, 52, "Text"],

Cell[CellGroupData[{
Cell[28751, 940, 82, 1, 27, "Input"],
Cell[28836, 943, 51, 1, 23, "Print"]
}, Open  ]],
Cell[28902, 947, 176, 4, 52, "Text"],

Cell[CellGroupData[{
Cell[29103, 955, 283, 10, 27, "Input"],
Cell[29389, 967, 45, 1, 27, "Output"]
}, Open  ]],
Cell[29449, 971, 494, 15, 109, "Text"],
Cell[29946, 988, 344, 7, 71, "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[30339, 1001, 46, 0, 61, "Section"],

Cell[CellGroupData[{
Cell[30410, 1005, 35, 0, 49, "Subsection"],

Cell[CellGroupData[{
Cell[30470, 1009, 99, 3, 47, "Subsubsection"],
Cell[30572, 1014, 1259, 33, 295, "Text"],
Cell[31834, 1049, 263, 9, 52, "Text"],
Cell[32100, 1060, 107, 2, 27, "Input"],

Cell[CellGroupData[{
Cell[32232, 1066, 105, 2, 27, "Input"],
Cell[32340, 1070, 52, 1, 27, "Output"]
}, Open  ]],
Cell[32407, 1074, 301, 7, 71, "Text"],
Cell[32711, 1083, 61, 0, 33, "Text"],
Cell[32775, 1085, 163, 3, 43, "Input"],
Cell[32941, 1090, 878, 24, 238, "Text"],

Cell[CellGroupData[{
Cell[33844, 1118, 376, 5, 139, "Input"],
Cell[34223, 1125, 132, 2, 45, "Output"]
}, Open  ]],
Cell[34370, 1130, 131, 3, 52, "Text"],

Cell[CellGroupData[{
Cell[34526, 1137, 229, 3, 75, "Input"],
Cell[34758, 1142, 53, 1, 27, "Output"]
}, Open  ]],
Cell[34826, 1146, 195, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[35046, 1156, 242, 4, 75, "Input"],
Cell[35291, 1162, 49, 1, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[35389, 1169, 201, 4, 75, "Subsubsection"],

Cell[CellGroupData[{
Cell[35615, 1177, 235, 5, 75, "Input"],
Cell[35853, 1184, 81, 1, 29, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[35971, 1190, 240, 4, 75, "Input"],
Cell[36214, 1196, 53, 1, 27, "Output"]
}, Open  ]],
Cell[36282, 1200, 372, 7, 71, "Text"],
Cell[36657, 1209, 66, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[36748, 1214, 64, 1, 27, "Input"],
Cell[36815, 1217, 76, 1, 27, "Output"]
}, Open  ]],
Cell[36906, 1221, 317, 11, 52, "Text"],

Cell[CellGroupData[{
Cell[37248, 1236, 72, 1, 27, "Input"],
Cell[37323, 1239, 82, 1, 27, "Output"]
}, Open  ]],
Cell[37420, 1243, 174, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[37619, 1253, 159, 3, 75, "Input"],
Cell[37781, 1258, 72, 1, 29, "Output"]
}, Open  ]],
Cell[37868, 1262, 155, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[38048, 1271, 181, 3, 59, "Input"],
Cell[38232, 1276, 212, 3, 43, "Output"]
}, Open  ]],
Cell[38459, 1282, 225, 5, 52, "Text"],

Cell[CellGroupData[{
Cell[38709, 1291, 47, 1, 27, "Input"],
Cell[38759, 1294, 91, 2, 29, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[38899, 1302, 111, 3, 54, "Subsubsection"],
Cell[39013, 1307, 297, 9, 52, "Text"],

Cell[CellGroupData[{
Cell[39335, 1320, 186, 3, 59, "Input"],
Cell[39524, 1325, 71, 2, 29, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[39632, 1332, 144, 3, 43, "Input"],
Cell[39779, 1337, 71, 2, 29, "Output"]
}, Open  ]],
Cell[39865, 1342, 1629, 50, 350, "Text"],

Cell[CellGroupData[{
Cell[41519, 1396, 248, 4, 91, "Input"],
Cell[41770, 1402, 72, 2, 29, "Output"]
}, Open  ]],
Cell[41857, 1407, 289, 9, 52, "Text"],
Cell[42149, 1418, 25, 3, 52, "Text"],
Cell[42177, 1423, 232, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[42434, 1433, 227, 3, 91, "Input"],
Cell[42664, 1438, 40, 1, 27, "Output"]
}, Open  ]],
Cell[42719, 1442, 392, 7, 90, "Text"],
Cell[43114, 1451, 25, 3, 52, "Text"],
Cell[43142, 1456, 2676, 85, 337, "Text"],

Cell[CellGroupData[{
Cell[45843, 1545, 348, 7, 155, "Input"],
Cell[46194, 1554, 43, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[46274, 1560, 59, 1, 27, "Input"],
Cell[46336, 1563, 35, 1, 27, "Output"],
Cell[46374, 1566, 43, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[46454, 1572, 56, 1, 27, "Input"],
Cell[46513, 1575, 35, 1, 27, "Output"],
Cell[46551, 1578, 43, 1, 23, "Print"]
}, Open  ]],
Cell[46609, 1582, 65, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[46699, 1587, 133, 2, 59, "Input"],
Cell[46835, 1591, 35, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[46907, 1597, 41, 1, 27, "Input"],
Cell[46951, 1600, 43, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[47031, 1606, 104, 2, 27, "Input"],
Cell[47138, 1610, 200, 7, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[47387, 1623, 108, 3, 33, "Subsubsection"],
Cell[47498, 1628, 1916, 36, 639, "Text"],
Cell[49417, 1666, 71, 1, 27, "Input"],
Cell[49491, 1669, 103, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[49619, 1676, 309, 9, 27, "Input"],
Cell[49931, 1687, 86, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[50054, 1693, 137, 3, 27, "Input"],
Cell[50194, 1698, 47, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[50278, 1704, 135, 3, 27, "Input"],
Cell[50416, 1709, 49, 1, 27, "Output"]
}, Open  ]],
Cell[50480, 1713, 382, 6, 90, "Text"],

Cell[CellGroupData[{
Cell[50887, 1723, 232, 4, 59, "Input"],
Cell[51122, 1729, 226, 5, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[51385, 1739, 47, 1, 27, "Input"],
Cell[51435, 1742, 35, 1, 27, "Output"]
}, Open  ]],
Cell[51485, 1746, 127, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[51637, 1753, 143, 3, 27, "Input"],
Cell[51783, 1758, 151, 3, 23, "Message"],
Cell[51937, 1763, 184, 3, 43, "Output"]
}, Open  ]],
Cell[52136, 1769, 60, 0, 33, "Text"],
Cell[52199, 1771, 1088, 25, 267, "Input"],
Cell[53290, 1798, 110, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[53425, 1805, 88, 1, 27, "Input"],
Cell[53516, 1808, 52, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[53605, 1814, 926, 38, 27, "Input"],
Cell[54534, 1854, 35, 1, 27, "Output"]
}, Open  ]],
Cell[54584, 1858, 72, 1, 27, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[54693, 1864, 59, 0, 33, "Subsubsection"],
Cell[54755, 1866, 247, 5, 71, "Text"],
Cell[55005, 1873, 243, 8, 52, "Text"],

Cell[CellGroupData[{
Cell[55273, 1885, 62, 1, 27, "Input"],
Cell[55338, 1888, 46, 1, 27, "Output"]
}, Open  ]],
Cell[55399, 1892, 33, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[55457, 1896, 103, 2, 27, "Input"],
Cell[55563, 1900, 129, 3, 44, "Output"]
}, Open  ]],
Cell[55707, 1906, 166, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[55898, 1915, 112, 2, 27, "Input"],
Cell[56013, 1919, 144, 3, 44, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[56206, 1928, 125, 3, 54, "Subsubsection"],
Cell[56334, 1933, 417, 7, 90, "Text"],

Cell[CellGroupData[{
Cell[56776, 1944, 148, 3, 43, "Input"],
Cell[56927, 1949, 732, 28, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[57696, 1982, 69, 1, 27, "Input"],
Cell[57768, 1985, 632, 24, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[58437, 2014, 84, 1, 27, "Input"],
Cell[58524, 2017, 631, 24, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[59192, 2046, 47, 1, 27, "Input"],
Cell[59242, 2049, 36, 1, 27, "Output"]
}, Open  ]],
Cell[59293, 2053, 354, 6, 90, "Text"],
Cell[59650, 2061, 544, 9, 155, "Input"],

Cell[CellGroupData[{
Cell[60219, 2074, 153, 3, 43, "Input"],
Cell[60375, 2079, 1020, 38, 32, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[61432, 2122, 74, 1, 27, "Input"],
Cell[61509, 2125, 892, 33, 32, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[62438, 2163, 101, 2, 27, "Input"],
Cell[62542, 2167, 891, 33, 32, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[63470, 2205, 105, 2, 27, "Input"],
Cell[63578, 2209, 36, 1, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[63663, 2216, 76, 0, 33, "Subsubsection"],
Cell[63742, 2218, 355, 7, 71, "Text"],

Cell[CellGroupData[{
Cell[64122, 2229, 163, 3, 43, "Input"],
Cell[64288, 2234, 86, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[64411, 2240, 61, 1, 27, "Input"],
Cell[64475, 2243, 77, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[64589, 2249, 68, 1, 27, "Input"],
Cell[64660, 2252, 76, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[64773, 2258, 105, 2, 27, "Input"],
Cell[64881, 2262, 36, 1, 27, "Output"]
}, Open  ]],
Cell[64932, 2266, 304, 5, 71, "Text"],
Cell[65239, 2273, 463, 13, 106, "Text"],

Cell[CellGroupData[{
Cell[65727, 2290, 525, 10, 123, "Input"],
Cell[66255, 2302, 36, 1, 27, "Output"]
}, Open  ]],
Cell[66306, 2306, 25, 3, 52, "Text"],
Cell[66334, 2311, 1193, 30, 185, "Text"],
Cell[67530, 2343, 1268, 27, 200, "Input"],

Cell[CellGroupData[{
Cell[68823, 2374, 384, 6, 120, "Input"],
Cell[69210, 2382, 36, 1, 40, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[69295, 2389, 102, 3, 33, "Subsubsection"],
Cell[69400, 2394, 542, 12, 128, "Text"],
Cell[69945, 2408, 45, 0, 33, "Text"],
Cell[69993, 2410, 46, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[70064, 2415, 66, 1, 27, "Input"],
Cell[70133, 2418, 54, 1, 44, "Output"]
}, Open  ]],
Cell[70202, 2422, 175, 4, 52, "Text"],
Cell[70380, 2428, 210, 5, 27, "Input"],

Cell[CellGroupData[{
Cell[70615, 2437, 86, 1, 31, "Input"],
Cell[70704, 2440, 84, 1, 46, "Output"]
}, Open  ]],
Cell[70803, 2444, 177, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[71005, 2453, 243, 4, 91, "Input"],
Cell[71251, 2459, 84, 1, 46, "Output"]
}, Open  ]],
Cell[71350, 2463, 218, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[71593, 2473, 288, 4, 107, "Input"],
Cell[71884, 2479, 401, 12, 25, "Print"],
Cell[72288, 2493, 84, 1, 46, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[72433, 2501, 55, 0, 49, "Subsection"],

Cell[CellGroupData[{
Cell[72513, 2505, 160, 4, 68, "Subsubsection"],
Cell[72676, 2511, 734, 20, 147, "Text"],

Cell[CellGroupData[{
Cell[73435, 2535, 134, 3, 43, "Input"],
Cell[73572, 2540, 368, 13, 40, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[73977, 2558, 156, 3, 43, "Input"],
Cell[74136, 2563, 701, 22, 34, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[74874, 2590, 299, 6, 91, "Input"],
Cell[75176, 2598, 346, 12, 40, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[75559, 2615, 59, 1, 27, "Input"],
Cell[75621, 2618, 39, 1, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[75709, 2625, 120, 3, 54, "Subsubsection"],
Cell[75832, 2630, 514, 12, 128, "Text"],
Cell[76349, 2644, 166, 2, 59, "Input"],
Cell[76518, 2648, 104, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[76647, 2655, 54, 1, 27, "Input"],
Cell[76704, 2658, 242, 8, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[76983, 2671, 48, 1, 27, "Input"],
Cell[77034, 2674, 243, 8, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[77314, 2687, 57, 1, 27, "Input"],
Cell[77374, 2690, 265, 8, 27, "Output"]
}, Open  ]],
Cell[77654, 2701, 249, 9, 52, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[77940, 2715, 82, 1, 33, "Subsubsection"],
Cell[78025, 2718, 427, 10, 71, "Text"],

Cell[CellGroupData[{
Cell[78477, 2732, 91, 1, 27, "Input"],
Cell[78571, 2735, 78, 2, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[78686, 2742, 109, 2, 27, "Input"],
Cell[78798, 2746, 92, 2, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[78927, 2753, 106, 2, 27, "Input"],
Cell[79036, 2757, 82, 2, 27, "Output"]
}, Open  ]],
Cell[79133, 2762, 225, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[79383, 2772, 107, 2, 27, "Input"],
Cell[79493, 2776, 86, 2, 27, "Output"]
}, Open  ]],
Cell[79594, 2781, 97, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[79716, 2788, 107, 2, 27, "Input"],
Cell[79826, 2792, 82, 2, 27, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[79981, 2802, 49, 0, 61, "Section"],

Cell[CellGroupData[{
Cell[80055, 2806, 114, 3, 70, "Subsection"],

Cell[CellGroupData[{
Cell[80194, 2813, 32, 0, 47, "Subsubsection"],
Cell[80229, 2815, 103, 5, 33, "Text"],
Cell[80335, 2822, 406, 7, 155, "Input"],

Cell[CellGroupData[{
Cell[80766, 2833, 177, 3, 27, "Input"],
Cell[80946, 2838, 183, 3, 27, "Output"]
}, Open  ]],
Cell[81144, 2844, 140, 3, 52, "Text"],
Cell[81287, 2849, 399, 7, 171, "Input"],

Cell[CellGroupData[{
Cell[81711, 2860, 84, 1, 27, "Input"],
Cell[81798, 2863, 62, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[81897, 2869, 37, 1, 27, "Input"],
Cell[81937, 2872, 35, 1, 27, "Output"]
}, Open  ]],
Cell[81987, 2876, 271, 8, 52, "Text"],
Cell[82261, 2886, 253, 4, 123, "Input"],

Cell[CellGroupData[{
Cell[82539, 2894, 84, 1, 27, "Input"],
Cell[82626, 2897, 124, 2, 23, "Message"],
Cell[82753, 2901, 65, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[82855, 2907, 37, 1, 27, "Input"],
Cell[82895, 2910, 124, 2, 23, "Message"],
Cell[83022, 2914, 44, 1, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[83115, 2921, 31, 0, 33, "Subsubsection"],
Cell[83149, 2923, 206, 4, 52, "Text"],
Cell[83358, 2929, 89, 1, 27, "Input"],
Cell[83450, 2932, 104, 2, 27, "Input"],
Cell[83557, 2936, 333, 11, 52, "Text"],
Cell[83893, 2949, 92, 1, 27, "Input"],
Cell[83988, 2952, 273, 7, 52, "Text"],
Cell[84264, 2961, 136, 2, 27, "Input"],
Cell[84403, 2965, 149, 3, 27, "Input"],
Cell[84555, 2970, 130, 5, 33, "Text"],
Cell[84688, 2977, 107, 2, 27, "Input"],
Cell[84798, 2981, 74, 0, 33, "Text"],
Cell[84875, 2983, 389, 12, 145, "Program"],
Cell[85267, 2997, 250, 8, 52, "Text"],
Cell[85520, 3007, 210, 4, 91, "Input"],
Cell[85733, 3013, 381, 11, 71, "Text"],
Cell[86117, 3026, 206, 4, 43, "Input"],
Cell[86326, 3032, 319, 11, 52, "Text"],
Cell[86648, 3045, 166, 3, 43, "Input"],
Cell[86817, 3050, 190, 3, 75, "Input"],
Cell[87010, 3055, 205, 8, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[87252, 3068, 86, 1, 33, "Subsubsection"],
Cell[87341, 3071, 439, 12, 71, "Text"],
Cell[87783, 3085, 401, 10, 71, "Text"],
Cell[88187, 3097, 152, 3, 43, "Input"],
Cell[88342, 3102, 217, 5, 52, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[88596, 3112, 114, 3, 54, "Subsubsection"],
Cell[88713, 3117, 135, 5, 33, "Text"],
Cell[88851, 3124, 362, 12, 52, "Text"],
Cell[89216, 3138, 1006, 30, 128, "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[90271, 3174, 53, 0, 49, "Subsection"],

Cell[CellGroupData[{
Cell[90349, 3178, 283, 9, 89, "Subsubsection"],
Cell[90635, 3189, 1271, 41, 204, "Text"],
Cell[91909, 3232, 46, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[91980, 3237, 43, 1, 27, "Input"],
Cell[92026, 3240, 43, 1, 27, "Output"]
}, Open  ]],
Cell[92084, 3244, 72, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[92181, 3249, 43, 1, 27, "Input"],
Cell[92227, 3252, 168, 3, 39, "Message"],
Cell[92398, 3257, 46, 1, 27, "Output"]
}, Open  ]],
Cell[92459, 3261, 70, 1, 27, "Input"],
Cell[92532, 3264, 748, 22, 109, "Text"],
Cell[93283, 3288, 166, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[93474, 3299, 49, 1, 27, "Input"],
Cell[93526, 3302, 54, 1, 27, "Output"]
}, Open  ]],
Cell[93595, 3306, 175, 8, 33, "Text"],

Cell[CellGroupData[{
Cell[93795, 3318, 85, 1, 27, "Input"],
Cell[93883, 3321, 54, 1, 27, "Output"]
}, Open  ]],
Cell[93952, 3325, 128, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[94105, 3333, 93, 1, 27, "Input"],
Cell[94201, 3336, 86, 1, 27, "Output"]
}, Open  ]],
Cell[94302, 3340, 412, 10, 71, "Text"],
Cell[94717, 3352, 260, 7, 52, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[95014, 3364, 297, 9, 75, "Subsubsection"],
Cell[95314, 3375, 530, 18, 71, "Text"],
Cell[95847, 3395, 159, 2, 43, "Input"],
Cell[96009, 3399, 408, 10, 71, "Text"],
Cell[96420, 3411, 503, 16, 71, "Text"],
Cell[96926, 3429, 3314, 136, 432, "Text"],
Cell[100243, 3567, 71, 1, 33, "Text"],
Cell[100317, 3570, 345, 8, 109, "Text"],
Cell[100665, 3580, 224, 10, 33, "Text"],

Cell[CellGroupData[{
Cell[100914, 3594, 221, 4, 91, "Input"],
Cell[101138, 3600, 35, 1, 27, "Output"]
}, Open  ]],
Cell[101188, 3604, 209, 8, 33, "Text"],

Cell[CellGroupData[{
Cell[101422, 3616, 224, 4, 91, "Input"],
Cell[101649, 3622, 34, 1, 23, "Print"],
Cell[101686, 3625, 35, 1, 27, "Output"]
}, Open  ]],
Cell[101736, 3629, 268, 6, 52, "Text"],
Cell[102007, 3637, 168, 4, 52, "Text"],

Cell[CellGroupData[{
Cell[102200, 3645, 168, 3, 59, "Input"],
Cell[102371, 3650, 44, 1, 29, "Output"]
}, Open  ]],
Cell[102430, 3654, 272, 9, 52, "Text"],

Cell[CellGroupData[{
Cell[102727, 3667, 121, 2, 59, "Input"],
Cell[102851, 3671, 35, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[102923, 3677, 125, 2, 59, "Input"],
Cell[103051, 3681, 35, 1, 27, "Output"]
}, Open  ]],
Cell[103101, 3685, 117, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[103243, 3694, 192, 3, 59, "Input"],
Cell[103438, 3699, 79, 1, 23, "Print"]
}, Open  ]],
Cell[103532, 3703, 670, 19, 90, "Text"],
Cell[104205, 3724, 45, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[104275, 3728, 108, 2, 27, "Input"],
Cell[104386, 3732, 85, 2, 27, "Output"]
}, Open  ]],
Cell[104486, 3737, 148, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[104659, 3746, 219, 3, 91, "Input"],
Cell[104881, 3751, 60, 1, 23, "Print"]
}, Open  ]],
Cell[104956, 3755, 319, 9, 90, "Text"],
Cell[105278, 3766, 130, 5, 37, "Text"],
Cell[105411, 3773, 358, 10, 71, "Text"],

Cell[CellGroupData[{
Cell[105794, 3787, 78, 1, 27, "Input"],
Cell[105875, 3790, 44, 1, 37, "Print"]
}, Open  ]],
Cell[105934, 3794, 43, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[106002, 3798, 88, 1, 27, "Input"],
Cell[106093, 3801, 68, 1, 23, "Print"]
}, Open  ]],
Cell[106176, 3805, 410, 13, 71, "Text"],
Cell[106589, 3820, 175, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[106789, 3829, 60, 1, 27, "Input"],
Cell[106852, 3832, 130, 2, 36, "Message"],
Cell[106985, 3836, 93, 2, 27, "Output"]
}, Open  ]],
Cell[107093, 3841, 104, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[107222, 3849, 56, 1, 27, "Input"],
Cell[107281, 3852, 93, 2, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[107423, 3860, 75, 0, 33, "Subsubsection"],
Cell[107501, 3862, 1706, 45, 372, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[109244, 3912, 79, 0, 33, "Subsubsection"],
Cell[109326, 3914, 817, 23, 242, "Text"],
Cell[110146, 3939, 115, 5, 71, "Text"],
Cell[110264, 3946, 147, 5, 33, "Text"],
Cell[110414, 3953, 431, 12, 71, "Text"],
Cell[110848, 3967, 1137, 26, 261, "Text"],
Cell[111988, 3995, 112, 4, 33, "Text"],
Cell[112103, 4001, 631, 20, 128, "Text"],
Cell[112737, 4023, 647, 23, 90, "Text"],
Cell[113387, 4048, 136, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[113548, 4057, 151, 3, 43, "Input"],
Cell[113702, 4062, 122, 2, 27, "Output"]
}, Open  ]],
Cell[113839, 4067, 714, 24, 90, "Text"],
Cell[114556, 4093, 239, 6, 52, "Text"],
Cell[114798, 4101, 125, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[114948, 4110, 148, 3, 43, "Input"],
Cell[115099, 4115, 147, 2, 43, "Output"]
}, Open  ]],
Cell[115261, 4120, 965, 30, 128, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[116263, 4155, 261, 5, 96, "Subsubsection"],
Cell[116527, 4162, 905, 26, 223, "Text"],
Cell[117435, 4190, 341, 9, 63, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[117813, 4204, 143, 3, 54, "Subsubsection"],
Cell[117959, 4209, 455, 13, 71, "Text"],

Cell[CellGroupData[{
Cell[118439, 4226, 74, 1, 27, "Input"],
Cell[118516, 4229, 51, 1, 27, "Output"]
}, Open  ]],
Cell[118582, 4233, 263, 8, 52, "Text"],
Cell[118848, 4243, 273, 7, 52, "Text"],
Cell[119124, 4252, 61, 1, 27, "Input"],
Cell[119188, 4255, 62, 1, 27, "Input"],
Cell[119253, 4258, 60, 1, 27, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[119350, 4264, 138, 3, 54, "Subsubsection"],
Cell[119491, 4269, 149, 3, 43, "Input"],
Cell[119643, 4274, 61, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[119729, 4279, 37, 1, 27, "Input"],
Cell[119769, 4282, 42, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[119848, 4288, 50, 1, 27, "Input"],
Cell[119901, 4291, 42, 1, 23, "Print"]
}, Open  ]],
Cell[119958, 4295, 261, 9, 52, "Text"],
Cell[120222, 4306, 102, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[120349, 4313, 40, 1, 27, "Input"],
Cell[120392, 4316, 42, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[120471, 4322, 44, 1, 27, "Input"],
Cell[120518, 4325, 42, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[120597, 4331, 41, 1, 27, "Input"],
Cell[120641, 4334, 42, 1, 23, "Print"],
Cell[120686, 4337, 43, 1, 23, "Print"],
Cell[120732, 4340, 421, 12, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[121190, 4357, 189, 4, 75, "Input"],
Cell[121382, 4363, 42, 1, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[121461, 4369, 39, 1, 27, "Input"],
Cell[121503, 4372, 42, 1, 23, "Print"],
Cell[121548, 4375, 43, 1, 23, "Print"],
Cell[121594, 4378, 421, 12, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[122052, 4395, 71, 1, 27, "Input"],
Cell[122126, 4398, 35, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[122198, 4404, 41, 1, 27, "Input"],
Cell[122242, 4407, 42, 1, 23, "Print"],
Cell[122287, 4410, 43, 1, 23, "Print"],
Cell[122333, 4413, 657, 19, 59, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[123027, 4437, 76, 1, 27, "Input"],
Cell[123106, 4440, 421, 12, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[123564, 4457, 80, 1, 27, "Input"],
Cell[123647, 4460, 590, 16, 23, "Print"]
}, Open  ]],
Cell[124252, 4479, 48, 0, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[124337, 4484, 100, 3, 33, "Subsubsection"],
Cell[124440, 4489, 92, 2, 37, "Text"],
Cell[124535, 4493, 75, 0, 33, "Text"],
Cell[124613, 4495, 1331, 47, 147, "Text"],
Cell[125947, 4544, 70, 1, 27, "Input"],
Cell[126020, 4547, 104, 3, 33, "Text"],
Cell[126127, 4552, 103, 2, 27, "Input"],
Cell[126233, 4556, 1123, 46, 109, "Text"],
Cell[127359, 4604, 826, 28, 109, "Text"],

Cell[CellGroupData[{
Cell[128210, 4636, 237, 4, 91, "Input"],
Cell[128450, 4642, 42, 1, 23, "Print"]
}, Open  ]],
Cell[128507, 4646, 1064, 26, 223, "Text"],
Cell[129574, 4674, 549, 16, 147, "Text"],
Cell[130126, 4692, 27, 5, 90, "Text"],
Cell[130156, 4699, 372, 7, 109, "Text"],
Cell[130531, 4708, 147, 2, 59, "Input"],
Cell[130681, 4712, 643, 15, 166, "Text"],
Cell[131327, 4729, 1079, 23, 223, "Text"],
Cell[132409, 4754, 108, 2, 37, "Text"],
Cell[132520, 4758, 591, 11, 155, "Input"],

Cell[CellGroupData[{
Cell[133136, 4773, 42, 1, 27, "Input"],
Cell[133181, 4776, 135, 2, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[133353, 4783, 296, 6, 59, "Input"],
Cell[133652, 4791, 1482, 20, 315, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[135171, 4816, 234, 5, 43, "Input"],
Cell[135408, 4823, 258, 4, 59, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[135703, 4832, 182, 3, 59, "Input"],
Cell[135888, 4837, 290, 4, 59, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[136227, 4847, 228, 5, 75, "Subsubsection"],
Cell[136458, 4854, 119, 3, 33, "Text"],
Cell[136580, 4859, 264, 6, 91, "Input"],
Cell[136847, 4867, 850, 24, 147, "Text"],
Cell[137700, 4893, 189, 4, 52, "Text"],
Cell[137892, 4899, 207, 3, 75, "Input"],
Cell[138102, 4904, 56, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[138183, 4908, 64, 1, 27, "Input"],
Cell[138250, 4911, 49, 1, 27, "Output"]
}, Open  ]],
Cell[138314, 4915, 46, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[138385, 4919, 91, 1, 27, "Input"],
Cell[138479, 4922, 34, 1, 23, "Print"],
Cell[138516, 4925, 59, 1, 27, "Output"]
}, Open  ]],
Cell[138590, 4929, 117, 3, 33, "Text"],
Cell[138710, 4934, 225, 5, 59, "Input"],

Cell[CellGroupData[{
Cell[138960, 4943, 91, 1, 27, "Input"],
Cell[139054, 4946, 67, 1, 27, "Output"]
}, Open  ]],
Cell[139136, 4950, 97, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[139258, 4957, 77, 1, 27, "Input"],
Cell[139338, 4960, 36, 1, 27, "Output"]
}, Open  ]],
Cell[139389, 4964, 356, 14, 52, "Text"],
Cell[139748, 4980, 228, 9, 33, "Text"],
Cell[139979, 4991, 357, 7, 107, "Input"],

Cell[CellGroupData[{
Cell[140361, 5002, 77, 1, 27, "Input"],
Cell[140441, 5005, 42, 1, 29, "Output"]
}, Open  ]],
Cell[140498, 5009, 354, 11, 63, "Text"],
Cell[140855, 5022, 279, 5, 71, "Text"],
Cell[141137, 5029, 283, 7, 71, "Text"],
Cell[141423, 5038, 528, 10, 147, "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[142000, 5054, 74, 0, 49, "Subsection"],

Cell[CellGroupData[{
Cell[142099, 5058, 114, 5, 110, "Subsubsection"],
Cell[142216, 5065, 54, 0, 33, "Text"],
Cell[142273, 5067, 361, 14, 52, "Text"],
Cell[142637, 5083, 24, 0, 33, "Text"],
Cell[142664, 5085, 42, 1, 27, "Input"],
Cell[142709, 5088, 54, 1, 27, "Input"],
Cell[142766, 5091, 56, 1, 27, "Input"],
Cell[142825, 5094, 69, 1, 27, "Input"],
Cell[142897, 5097, 69, 1, 27, "Input"],
Cell[142969, 5100, 345, 15, 52, "Text"],
Cell[143317, 5117, 25, 0, 33, "Text"],
Cell[143345, 5119, 177, 5, 27, "Input"],
Cell[143525, 5126, 174, 5, 27, "Input"],
Cell[143702, 5133, 1268, 36, 204, "Text"],
Cell[144973, 5171, 359, 9, 52, "Text"],
Cell[145335, 5182, 302, 6, 91, "Input"],
Cell[145640, 5190, 97, 3, 30, "Input"],
Cell[145740, 5195, 1467, 47, 204, "Text"],
Cell[147210, 5244, 217, 5, 52, "Text"],
Cell[147430, 5251, 295, 5, 91, "Input"],
Cell[147728, 5258, 247, 4, 91, "Input"],
Cell[147978, 5264, 287, 5, 91, "Input"],
Cell[148268, 5271, 326, 11, 52, "Text"],
Cell[148597, 5284, 47, 1, 27, "Input"],
Cell[148647, 5287, 186, 6, 52, "Text"],
Cell[148836, 5295, 1026, 26, 337, "Text"],
Cell[149865, 5323, 64, 0, 33, "Text"],
Cell[149932, 5325, 355, 11, 27, "Input"],
Cell[150290, 5338, 476, 24, 34, "Text"],
Cell[150769, 5364, 722, 22, 128, "Text"],
Cell[151494, 5388, 105, 2, 27, "Input"],
Cell[151602, 5392, 72, 1, 27, "Input"],
Cell[151677, 5395, 102, 2, 27, "Input"],
Cell[151782, 5399, 258, 7, 52, "Text"],
Cell[152043, 5408, 319, 7, 75, "Input"],
Cell[152365, 5417, 191, 3, 43, "Input"],

Cell[CellGroupData[{
Cell[152581, 5424, 68, 1, 27, "Input"],
Cell[152652, 5427, 38, 1, 27, "Output"]
}, Open  ]],
Cell[152705, 5431, 91, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[152821, 5438, 122, 2, 27, "Input"],
Cell[152946, 5442, 1375, 24, 235, "Output"]
}, Open  ]],
Cell[154336, 5469, 236, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[154597, 5479, 93, 1, 27, "Input"],
Cell[154693, 5482, 551, 10, 123, "Output"]
}, Open  ]],
Cell[155259, 5495, 25, 3, 52, "Text"],
Cell[155287, 5500, 327, 10, 71, "Text"],
Cell[155617, 5512, 902, 25, 27, "Input"],
Cell[156522, 5539, 765, 17, 120, "Text"],

Cell[CellGroupData[{
Cell[157312, 5560, 48, 1, 27, "Input"],
Cell[157363, 5563, 35, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[157435, 5569, 72, 1, 27, "Input"],
Cell[157510, 5572, 269, 8, 27, "Output"]
}, Open  ]],
Cell[157794, 5583, 857, 21, 128, "Text"],

Cell[CellGroupData[{
Cell[158676, 5608, 52, 1, 27, "Input"],
Cell[158731, 5611, 35, 1, 27, "Output"]
}, Open  ]],
Cell[158781, 5615, 53, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[158859, 5620, 34, 1, 27, "Input"],
Cell[158896, 5623, 95, 3, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[159028, 5631, 72, 1, 27, "Input"],
Cell[159103, 5634, 364, 11, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[159504, 5650, 135, 3, 59, "Input"],
Cell[159642, 5655, 38, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[159717, 5661, 54, 1, 27, "Input"],
Cell[159774, 5664, 37, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[159848, 5670, 83, 1, 27, "Input"],
Cell[159934, 5673, 48, 1, 23, "Print"],
Cell[159985, 5676, 559, 17, 23, "Print"]
}, Open  ]],

Cell[CellGroupData[{
Cell[160581, 5698, 79, 1, 27, "Input"],
Cell[160663, 5701, 43, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[160743, 5707, 62, 1, 27, "Input"],
Cell[160808, 5710, 245, 7, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[161090, 5722, 58, 1, 27, "Input"],
Cell[161151, 5725, 36, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[161224, 5731, 54, 1, 27, "Input"],
Cell[161281, 5734, 56, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[161374, 5740, 85, 1, 27, "Input"],
Cell[161462, 5743, 36, 1, 27, "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[161547, 5750, 73, 0, 33, "Subsubsection"],
Cell[161623, 5752, 294, 6, 90, "Text"],
Cell[161920, 5760, 209, 4, 52, "Text"],
Cell[162132, 5766, 49, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[162206, 5771, 228, 5, 43, "Input"],
Cell[162437, 5778, 171, 2, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[162645, 5785, 87, 1, 27, "Input"],
Cell[162735, 5788, 194, 3, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[162966, 5796, 85, 1, 27, "Input"],
Cell[163054, 5799, 193, 3, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[163284, 5807, 132, 3, 27, "Input"],
Cell[163419, 5812, 105, 2, 27, "Output"]
}, Open  ]],
Cell[163539, 5817, 373, 12, 52, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[163949, 5834, 82, 1, 33, "Subsubsection"],
Cell[164034, 5837, 58, 0, 33, "Text"],
Cell[164095, 5839, 450, 8, 187, "Input"],
Cell[164548, 5849, 262, 6, 52, "Text"],
Cell[164813, 5857, 382, 7, 123, "Input"],
Cell[165198, 5866, 301, 9, 52, "Text"],
Cell[165502, 5877, 87, 1, 27, "Input"],
Cell[165592, 5880, 26, 4, 71, "Text"],
Cell[165621, 5886, 122, 3, 33, "Text"],
Cell[165746, 5891, 158, 3, 52, "Text"],
Cell[165907, 5896, 296, 6, 109, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[166240, 5907, 87, 1, 33, "Subsubsection"],
Cell[166330, 5910, 306, 9, 52, "Text"],
Cell[166639, 5921, 123, 2, 59, "Input"],

Cell[CellGroupData[{
Cell[166787, 5927, 72, 1, 27, "Input"],
Cell[166862, 5930, 115, 2, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[167014, 5937, 75, 1, 27, "Input"],
Cell[167092, 5940, 159, 2, 43, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[167288, 5947, 55, 1, 27, "Input"],
Cell[167346, 5950, 479, 9, 65, "Output"]
}, Open  ]],
Cell[167840, 5962, 617, 16, 109, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[168494, 5983, 104, 3, 33, "Subsubsection"],
Cell[168601, 5988, 93, 3, 33, "Text"],
Cell[168697, 5993, 177, 3, 59, "Input"],

Cell[CellGroupData[{
Cell[168899, 6000, 78, 1, 27, "Input"],
Cell[168980, 6003, 131, 3, 23, "Print"],
Cell[169114, 6008, 133, 3, 23, "Print"],
Cell[169250, 6013, 74, 1, 27, "Output"]
}, Open  ]],
Cell[169339, 6017, 268, 5, 71, "Text"],
Cell[169610, 6024, 214, 4, 59, "Input"],

Cell[CellGroupData[{
Cell[169849, 6032, 78, 1, 27, "Input"],
Cell[169930, 6035, 158, 4, 23, "Print"],
Cell[170091, 6041, 158, 4, 23, "Print"],
Cell[170252, 6047, 74, 1, 27, "Output"]
}, Open  ]],
Cell[170341, 6051, 676, 23, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[171054, 6079, 210, 4, 75, "Subsubsection"],
Cell[171267, 6085, 622, 21, 71, "Text"],
Cell[171892, 6108, 43, 0, 33, "Text"],
Cell[171938, 6110, 60, 1, 27, "Input"],
Cell[172001, 6113, 57, 1, 27, "Input"],
Cell[172061, 6116, 125, 2, 59, "Input"],
Cell[172189, 6120, 481, 15, 71, "Text"],
Cell[172673, 6137, 115, 2, 59, "Input"],
Cell[172791, 6141, 661, 25, 71, "Text"],
Cell[173455, 6168, 146, 3, 27, "Input"],
Cell[173604, 6173, 103, 3, 33, "Text"],
Cell[173710, 6178, 122, 2, 59, "Input"],
Cell[173835, 6182, 74, 1, 27, "Input"],
Cell[173912, 6185, 112, 2, 27, "Input"],
Cell[174027, 6189, 197, 4, 43, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[174261, 6198, 106, 3, 33, "Subsubsection"],
Cell[174370, 6203, 315, 7, 109, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[174722, 6215, 126, 3, 54, "Subsubsection"],
Cell[174851, 6220, 585, 13, 128, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[175473, 6238, 257, 5, 75, "Subsubsection"],
Cell[175733, 6245, 456, 9, 90, "Text"],
Cell[176192, 6256, 342, 6, 91, "Input"],
Cell[176537, 6264, 65, 0, 33, "Text"],
Cell[176605, 6266, 158, 3, 43, "Input"],

Cell[CellGroupData[{
Cell[176788, 6273, 50, 1, 27, "Input"],
Cell[176841, 6276, 103, 2, 27, "Output"]
}, Open  ]],
Cell[176959, 6281, 203, 6, 52, "Text"],

Cell[CellGroupData[{
Cell[177187, 6291, 59, 1, 27, "Input"],
Cell[177249, 6294, 35, 1, 27, "Output"]
}, Open  ]],
Cell[177299, 6298, 51, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[177375, 6302, 45, 1, 27, "Input"],
Cell[177423, 6305, 36, 1, 27, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[177532, 6314, 32, 0, 61, "Section"],
Cell[177567, 6316, 117, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[177709, 6323, 127, 3, 68, "Subsubsection"],
Cell[177839, 6328, 90, 3, 33, "Text"],
Cell[177932, 6333, 110, 2, 27, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[178079, 6340, 122, 3, 54, "Subsubsection"],
Cell[178204, 6345, 597, 20, 128, "Text"],

Cell[CellGroupData[{
Cell[178826, 6369, 177, 3, 59, "Input"],
Cell[179006, 6374, 49, 1, 27, "Output"]
}, Open  ]],
Cell[179070, 6378, 363, 12, 52, "Text"],

Cell[CellGroupData[{
Cell[179458, 6394, 80, 1, 27, "Input"],
Cell[179541, 6397, 73, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[179651, 6403, 89, 1, 27, "Input"],
Cell[179743, 6406, 80, 1, 27, "Output"]
}, Open  ]],
Cell[179838, 6410, 240, 6, 52, "Text"],
Cell[180081, 6418, 110, 2, 27, "Input"],

Cell[CellGroupData[{
Cell[180216, 6424, 54, 1, 27, "Input"],
Cell[180273, 6427, 58, 1, 23, "Print"],
Cell[180334, 6430, 706, 18, 112, "Print"]
}, Open  ]],
Cell[181055, 6451, 512, 17, 71, "Text"],

Cell[CellGroupData[{
Cell[181592, 6472, 90, 1, 27, "Input"],
Cell[181685, 6475, 83, 1, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[181805, 6481, 117, 2, 27, "Input"],
Cell[181925, 6485, 445, 15, 27, "Output"]
}, Open  ]],
Cell[182385, 6503, 500, 16, 52, "Text"],
Cell[182888, 6521, 151, 3, 43, "Input"],
Cell[183042, 6526, 165, 3, 43, "Input"],
Cell[183210, 6531, 517, 13, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[183764, 6549, 65, 0, 33, "Subsubsection"],
Cell[183832, 6551, 373, 11, 90, "Text"],
Cell[184208, 6564, 94, 3, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[184339, 6572, 102, 3, 33, "Subsubsection"],
Cell[184444, 6577, 144, 3, 52, "Text"],
Cell[184591, 6582, 402, 7, 123, "Input"],
Cell[184996, 6591, 164, 4, 52, "Text"]
}, Closed]]
}, Open  ]]
}
]
*)




(***********************************************************************
End of Mathematica Notebook file.
***********************************************************************)

