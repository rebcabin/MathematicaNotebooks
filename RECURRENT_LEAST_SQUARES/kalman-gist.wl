(* ::Package:: *)

(* ::Title:: *)
(*Kalman Folding*)


(* ::Author:: *)
(*Brian Beckman*)


(* ::Date:: *)
(*17 April 2016*)


(* ::Chapter:: *)
(*Preliminaries*)


(* ::Input:: *)
(*<<"Notation`"*)
(*InfixNotation[ParsedBoxWrapper["\[CirclePlus]"],Join];*)


(* ::Input:: *)
(*ClearAll[col,row,id,con,zero,len,dim,m,f1,inv,pinv,scalar,groundTruth];*)
(*col[xs_List]:=List/@xs;*)
(*row[xs_List]:=List[xs];*)
(*id=IdentityMatrix;*)
(*con[c_,m_,n_]:=ConstantArray[c,{m,n}];*)
(*con[c_,n_]:=con[c,n,n];*)
(*zero[m_,n_]:=con[0,m,n];*)
(*zero[n_]:=con[0,n];*)
(*len=Length;*)
(*dim[squareMatrix_List]:=len[squareMatrix[[1]]];*)
(*m=MatrixForm;*)
(*f1=Flatten[#,1]&;*)
(*inv=Inverse;*)
(*pinv=PseudoInverse;*)
(*scalar[m1x1_]:=m1x1[[1,1]];*)
(*groundTruth=({*)
(* {-3},*)
(* {9},*)
(* {-4},*)
(* {-5}*)
(*});*)


(* ::Chapter:: *)
(*Time-Independent Model*)


(* ::Text:: *)
(*Unit observation covariance, Generalized below in the time-dependent model.*)


(* ::Input:: *)
(*ClearAll[kalman];*)
(*kalman[{x_,P_},{A_,z_}]:=*)
(*Module[{D,K},*)
(*D=id[len[z]]+A.P.Transpose[A];*)
(*K=P.A\[Transpose].inv[D];*)
(*{x+K.(z-A.x),P-K.D.Transpose[K]}];*)


(* ::Input:: *)
(*ClearAll[testCase];*)
(*m/@(testCase={*)
(*{{{1,0.,0.,0.}},{-2.28442}},*)
(*{{{1,1.,1.,1.}},{-4.83168}},*)
(*{{{1,-1.,1.,-1.}},{-10.4601}},*)
(*{{{1,-2.,4.,-8.}},{1.40488}},*)
(*{{{1,2.,4.,8.}},{-40.8079}}})*)


(* ::Input:: *)
(*m@(m/@#&/@*)
(*Chop[FoldList[*)
(*kalman,*)
(*{col[{0,0,0,0}],*)
(*id[4]*1000.0},*)
(*testCase*)
(*]])*)


(* ::Subchapter:: *)
(*Insensitivity to A-Priori Observation Covariance*)


(* ::Input:: *)
(*m/@Chop[Fold[kalman,{col[{0,0,0,0}],id[4]*1000.0},testCase]]*)


(* ::Input:: *)
(*m/@Chop[Fold[kalman,{col[{0,0,0,0}],id[4]*1000000.0},testCase]]*)


(* ::Chapter:: *)
(*Time-Dependent Filter*)


(* ::Subchapter:: *)
(*Process-Noise Matrix*)


(* ::Text:: *)
(*Process noise always enters the last state, and with a constant standard deviation. We must integrate the process-noise covariance matrix over a discrete time interval and a particular model of system dynamics to add its effects to the filter.*)


(* ::Input:: *)
(*ClearAll[Q,\[CapitalPhi],\[Sigma]x,t];*)
(*Q=({*)
(* {0, 0, 0},*)
(* {0, 0, 0},*)
(* {0, 0, 1}*)
(*});*)
(*\[CapitalPhi][t_]:=({*)
(* {1, t, t^2/2},*)
(* {0, 1, t},*)
(* {0, 0, 1}*)
(*});*)
(*Integrate[\[CapitalPhi][t].Q.Transpose[\[CapitalPhi][t]],{t,0,dt}]//m*)


(* ::Subchapter:: *)
(*As A Fold*)


(* ::Item:: *)
(*gen is a way to generate random samples from a covariance matrix. This only honors the diagonal terms, but each diagonal term individually.*)


(* ::Item:: *)
(*kalman is the Kalman filter with time-dependent dynamical process (also called state estimation).*)


(* ::Item:: *)
(*At the bottom, we validate that kalman degenerates to the original static case (also called parameter estimation).*)


(* ::Item:: *)
(*\[CapitalXi] is the integrated process-noise matrix. It depend on time and on the size of the time step.*)


(* ::Item:: *)
(*\[CapitalPhi] is the integral of the system-dynamics matrix F; more precisely, it is Exp[F t]. *)


(* ::Item:: *)
(*\[CapitalGamma] is time-step integral of system response G propagated by \[CapitalPhi].*)


(* ::Item:: *)
(*\[CapitalXi], \[CapitalPhi], \[CapitalGamma], and u may all depend on time and on the size of the time step. *)


(* ::Input:: *)
(*ClearAll[gen,kalman];*)
(*(* generate noisy fake observations *)*)
(*gen[P_]:=*)
(*Module[{\[Sigma]s},*)
(*\[Sigma]s=Sqrt/@Table[P[[i,i]],{i,dim[P]}];*)
(*If[Chop[#]==0,0,(* RandomVariate can't handle a zero \[Sigma] *)*)
(*RandomVariate[NormalDistribution[0.0,#]]]&/@\[Sigma]s];*)
(*(* this is a function-maker -- give it an obs noise covar and get a foldable function *)*)
(*kalman[\[CapitalZeta]_][{x_,P_},{\[CapitalXi]_,\[CapitalPhi]_,\[CapitalGamma]_,u_,A_,z_}]:=*)
(*Module[{x2,P2,D,K},*)
(*x2=\[CapitalPhi].x+\[CapitalGamma].u;*)
(*P2=\[CapitalXi]+\[CapitalPhi].P.Transpose[\[CapitalPhi]];*)
(*(* below this line is just like the time-independent model! *)*)
(*D=\[CapitalZeta]+A.P2.Transpose[A];*)
(*K=P2.Transpose[A].inv[D];*)
(*{x2+K.(z-A.x2),P2-K.D.Transpose[K]}];*)
(*(* show that it degenerates to the time-independent case *)*)
(*m/@*)
(*Chop[*)
(*With[{*)
(*\[CapitalXi]=zero[4],\[CapitalZeta]=id[1],*)
(*\[CapitalPhi]=id[4],\[CapitalGamma]=zero[4,1],u=zero[1]},*)
(*Fold[*)
(*kalman[\[CapitalZeta]],*)
(*{col[{0,0,0,0}],*)
(*id[4]*1000.0},*)
(*{\[CapitalXi],\[CapitalPhi],\[CapitalGamma],u}\[CirclePlus]#&/@testCase*)
(*]]]*)


(* ::Subchapter:: *)
(*Track a Falling Object*)


(* ::Text:: *)
(*Repro an example from Zarchan and Musoff, Fundamentals of Kalman Filtering, A Practical Approach, Ch. 4, track a falling object, no air drag. There are three states: the position x, velocity *)
(*\!\(\*OverscriptBox[\(x\), \(.\)]\), acceleration *)
(*\!\(\*OverscriptBox[\(x\), \(\[DoubleDot]\)]\) ; and the observations z directly measure the position state.*)


(* ::Text:: *)
(*State-space dynamics: *)


(* ::Input:: *)
(*ClearAll[x,xd,xdd,\[CapitalPsi],g,u,F,\[CapitalPhi],\[CapitalXi]c,\[CapitalXi],G,\[CapitalGamma],A];*)
(*g=-32.2;*)
(*u[t_]:=col[{g}];*)
(*\[CapitalPsi]=({*)
(* {x},*)
(* {xd},*)
(* {xdd}*)
(*});F=({*)
(* {0, 1, 0},*)
(* {0, 0, 1},*)
(* {0, 0, 0}*)
(*});G=({*)
(* {0},*)
(* {0},*)
(* {1}*)
(*});*)
(*\[CapitalPhi][dt_]:=({*)
(* {1, dt, dt^2/2},*)
(* {0, 1, dt},*)
(* {0, 0, 1}*)
(*});\[CapitalGamma][dt_]:=({*)
(* {dt^2/2},*)
(* {dt},*)
(* {1}*)
(*});*)
(*\[CapitalXi]c=({*)
(* {0, 0, 0},*)
(* {0, 0, 0},*)
(* {0, 0, 1}*)
(*});*)
(*\[CapitalXi][dt_]:=({*)
(* {dt^5/20, dt^4/8, dt^3/6},*)
(* {dt^4/8, dt^3/3, dt^2/2},*)
(* {dt^3/3, dt^2/2, dt}*)
(*});*)
(*A[t_]:=({*)
(* {1, 0, 0}*)
(*});*)


(* ::Input:: *)
(*ClearAll[experiment,withTimes,myStyle];*)
(*withTimes[times_,obj_]:=MapThread[List,{times,obj}];*)
(*myStyle[s_String]:=Style[s,FontFamily->"Candara",FontSize->12];*)
(**)
(*experiment[*)
(*startTime_,*)
(*endTime_,*)
(*timeIncrement_,*)
(*aPrioriState_,*)
(*aPrioriCovariance_,*)
(*fakeFn_,*)
(*trueObservationFn_,*)
(*trueObservationDerivativeFn_]:=*)
(*Module[{t,timesIter,times,fakes,ests},*)
(*timesIter={t,startTime,endTime,timeIncrement};*)
(*times=Table[t,Evaluate@timesIter];*)
(*fakes=Table[fakeFn[timeIncrement,t],Evaluate@timesIter];*)
(*ests=FoldList[kalman[\[CapitalZeta]],{aPrioriState,aPrioriCovariance},fakes];*)
(*Grid@{{ListLinePlot[{*)
(*withTimes[times,*)
(*Table[trueObservationFn[t],Evaluate@timesIter]-*)
(*ests[[;;,1,1,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Position Residual / foot",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Position Residuals vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium],*)
(*ListLinePlot[{*)
(*withTimes[times,*)
(*Table[trueObservationDerivativeFn[t],Evaluate@timesIter]-*)
(*ests[[2;;,1,2,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Speed Residual / [foot/sec]",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Speed Residuals vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium]}*)
(*{ListLinePlot[{*)
(*withTimes[times,Table[trueObservationFn[t],Evaluate@timesIter]],*)
(*withTimes[times,ests[[2;;,1,1,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Position / foot",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Position Truth and Estimate vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium],*)
(*ListLinePlot[{*)
(*withTimes[times,Table[trueObservationDerivativeFn[t],Evaluate@timesIter]],*)
(*withTimes[times,ests[[2;;,1,2,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Speed / [foot/sec]",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Speed Truth and Estimate\.7f vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium]}}];*)


(* ::Input:: *)
(*ClearAll[experiment,withTimes,myStyle];*)
(*withTimes[times_,obj_]:=MapThread[List,{times,obj}];*)
(*myStyle[s_String]:=Style[s,FontFamily->"Candara",FontSize->12];*)
(**)
(*experiment[*)
(*startTime_,*)
(*endTime_,*)
(*timeIncrement_,*)
(*aPrioriState_,*)
(*aPrioriCovariance_,*)
(*fakeFn_,*)
(*trueObservationFn_,*)
(*trueObservationDerivativeFn_]:=*)
(*Module[{t,timesIter,times,fakes,ests},*)
(*timesIter={t,startTime,endTime,timeIncrement};*)
(*times=Table[t,Evaluate@timesIter];*)
(*fakes=Table[fakeFn[timeIncrement,t],Evaluate@timesIter];*)
(*ests=FoldList[kalman[\[CapitalZeta]],{aPrioriState,aPrioriCovariance},fakes];*)
(*Grid@{{ListLinePlot[{*)
(*withTimes[times,*)
(*Table[trueObservationFn[t],Evaluate@timesIter]-ests[[2;;,1,1,1]]],*)
(*withTimes[times,Sqrt@ests[[2;;,2,1,1]]],*)
(*withTimes[times,-Sqrt@ests[[2;;,2,1,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Position Residual / foot",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Position Residuals vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium],*)
(*ListLinePlot[{*)
(*withTimes[times,*)
(*Table[trueObservationDerivativeFn[t],Evaluate@timesIter]-ests[[2;;,1,2,1]]],*)
(*withTimes[times,Sqrt@ests[[2;;,2,2,2]]],*)
(*withTimes[times,-Sqrt@ests[[2;;,2,2,2]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Speed Residual / [foot/sec]",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Speed Residuals vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium]},*)
(*{ListLinePlot[{*)
(*withTimes[times,Table[trueObservationFn[t],Evaluate@timesIter]],*)
(*withTimes[times,ests[[2;;,1,1,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Position / foot",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Position Truth and Estimates vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium],*)
(*ListLinePlot[{*)
(*withTimes[times,Table[trueObservationDerivativeFn[t],Evaluate@timesIter]],*)
(*withTimes[times,ests[[2;;,1,2,1]]]},*)
(*Frame->True,*)
(*FrameLabel->{{*)
(*myStyle@"Speed / [foot/sec]",""},{*)
(*myStyle@"time / sec",*)
(*myStyle@"Speed Truth and Estimate\.7fs vs. Time"}},*)
(*GridLines->Automatic,*)
(*ImageSize->Medium]}}];*)


(* ::Input:: *)
(*With[{x0=400000,v0=-6000,a0=-32.2},*)
(*With[{*)
(*aPrioriState=zero[3,1](*col[{x0,v0,a0}]*),*)
(*aPrioriCovariance=1000000000000000id[3],*)
(*\[CapitalZeta]=col[{1000.0^2}]},*)
(*experiment[*)
(*0,57.5,0.1,*)
(*aPrioriState,aPrioriCovariance,*)
(*{dt,t}\[Function]*)
(*{0*({*)
(* {dt^5/20, dt^4/8, dt^3/6},*)
(* {dt^4/8, dt^3/3, dt^2/2},*)
(* {dt^3/3, dt^2/2, dt}*)
(*}),*)
(*({*)
(* {1, dt, dt^2/2},*)
(* {0, 1, dt},*)
(* {0, 0, 1}*)
(*}),*)
(*({*)
(* {dt^2/2},*)
(* {dt},*)
(* {1}*)
(*}),*)
(*zero[1],*)
(*({*)
(* {1, 0, 0}*)
(*}),*)
(*col[{x0+v0 t+(a0 t^2)/2}]+gen[\[CapitalZeta]]},*)
(*t\[Function]x0+v0 t+a0 t^2/2,*)
(*t\[Function]v0+a0 t*)
(*]]]*)


(* ::Text:: *)
(*Doesn't work well for a two-state system, but we can fix this.*)


(* ::Input:: *)
(*With[{x0=400000,v0=-6000,a0=-32.2,\[CapitalZeta]=col[{1000.0^2}]},*)
(*experiment[*)
(*0,30.,0.1,*)
(*col[{x0,v0}],*)
(*1000000id[2],*)
(*{dt,t}\[Function]*)
(*{1000000*({*)
(* {dt^3/3, dt^2/2},*)
(* {dt^2/2, dt}*)
(*}),*)
(*({*)
(* {1, dt},*)
(* {0, 1}*)
(*}),*)
(*({*)
(* {dt},*)
(* {1}*)
(*}),*)
(*col[{g}],*)
(*({*)
(* {1, 0}*)
(*}),*)
(*col[{x0+v0 t}]+gen[\[CapitalZeta]]},*)
(*t\[Function]x0+v0 t+a0 t^2/2,*)
(*t\[Function]v0+a0 t]]*)
